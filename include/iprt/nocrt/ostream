/** @file
 * IPRT / No-CRT - Minimal C++ ostream header.
 */

/*
 * Copyright (C) 2022 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 *
 * The contents of this file may alternatively be used under the terms
 * of the Common Development and Distribution License Version 1.0
 * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
 * VirtualBox OSE distribution, in which case the provisions of the
 * CDDL are applicable instead of those of the GPL.
 *
 * You may elect to license modified versions of this file under the
 * terms and conditions of either the GPL or the CDDL or both.
 */

#ifndef IPRT_INCLUDED_nocrt_ostream
#define IPRT_INCLUDED_nocrt_ostream
#ifndef RT_WITHOUT_PRAGMA_ONCE
# pragma once
#endif

/* Currently all in the ios header. */
#include <iprt/nocrt/ios>

namespace std
{
    /**
     * Basic output stream.
     */
    template<typename a_CharType, typename a_CharTraits /*= std::char_traits<a_CharType>*/ >
    class basic_ostream : public basic_ios<a_CharType, a_CharTraits>
    {
    public:
        explicit basic_ostream(std::basic_streambuf<a_CharType,a_CharTraits> *a_pBuf)
            : basic_ios(a_pBuf)
        { }
    private:
        basic_ostream(basic_ostream const &a_rSrc);             /* not copyable */
        basic_ostream &operator=(basic_ostream const &a_rSrc);  /* not copyable */

    public:
        virtual ~basic_ostream()
        {
        }

    public:
        basic_ostream &put(char_type a_ch);
        basic_ostream &write(const char_type *a_pchSrc, std::streamsize a_cchToWrite);
        basic_ostream &flush();
        pos_type       tellp() RT_NOEXCEPT;
        basic_ostream &seekp(pos_type a_off) RT_NOEXCEPT;
        basic_ostream &seekp(off_type a_off, seekdir enmDir) RT_NOEXCEPT;

        /** @name Internal support methods
         * @{ */
        basic_ostream &intWrite(const char *a_pchSrc, std::streamsize a_cchToWrite); /**< Internal method outputting char buffers. */

        /** @returns 8, 10 or 16. */
        inline unsigned intGetIntegerBase() const RT_NOEXCEPT
        {
            switch (m_fFlags & basefield)
            {
                default:
                case dec: return 10;
                case hex: return 16;
                case oct: return 8;
            }
        }

        /** @returns RTSTR_F_XXX . */
        inline unsigned intGetIntegerFlags() const RT_NOEXCEPT
        {
            unsigned fFlags = 0;
            if (m_fFlags & uppercase)
                fFlags |= RTSTR_F_CAPITAL;
            if (m_fFlags & showbase)
                fFlags |= RTSTR_F_SPECIAL;
            if (m_fFlags & showpos)
                fFlags |= RTSTR_F_PLUS;
            return fFlags;
        }

        basic_ostream &formatInteger(uint64_t a_uValue, uint32_t fFlags)
        {
            fFlags |= intGetIntegerFlags();
            char szTmp[72];
            int  cchTmp = RTStrFormatNumber(szTmp, a_uValue, intGetIntegerBase(), 0, 0, fFlags);

            /** @todo apply cchWidth and padding.  */

            return intWrite(szTmp, cchTmp);
        }

        /** @} */
    };

    /** @name Character and string output.
     * @{ */
    /** @todo not sure if this really works...   */
    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, char a_ch)
    {
        return a_rDst.put(a_ch);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, const char *a_psz)
    {
        return a_rDst.intWrite(a_psz, strlen(a_psz));
    }
    /** @} */

    /** @name Integer formatting.
     * @{ */
    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, signed char a_iValue)
    {
        return a_rDst.formatInteger(a_iValue, RTSTR_F_8BIT | RTSTR_F_VALSIGNED);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, unsigned char a_uValue)
    {
        return a_rDst.formatInteger(a_uValue, RTSTR_F_8BIT);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, short a_iValue)
    {
        return a_rDst.formatInteger(a_iValue, RTSTR_F_16BIT | RTSTR_F_VALSIGNED);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, unsigned short a_uValue)
    {
        return a_rDst.formatInteger(a_uValue, RTSTR_F_16BIT);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, int a_iValue)
    {
        return a_rDst.formatInteger(a_iValue, RTSTR_F_32BIT | RTSTR_F_VALSIGNED);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, unsigned int a_uValue)
    {
        return a_rDst.formatInteger(a_uValue, RTSTR_F_32BIT | RTSTR_F_VALSIGNED);
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, long a_iValue)
    {
        return a_rDst.formatInteger(a_iValue, (sizeof(a_iValue) > sizeof(int32_t) ? RTSTR_F_64BIT : RTSTR_F_32BIT));
    }

    template<typename a_CharType, typename a_CharTraits = std::char_traits<a_CharType> >
    basic_ostream<a_CharType, a_CharTraits> &operator<<(basic_ostream<a_CharType, a_CharTraits> &a_rDst, unsigned long a_uValue)
    {
        return a_rDst.formatInteger(a_uValue,
                                    RTSTR_F_VALSIGNED | (sizeof(a_uValue) > sizeof(uint32_t) ? RTSTR_F_64BIT : RTSTR_F_32BIT));
    }
    /** @} */

}

#endif /* !IPRT_INCLUDED_nocrt_ostream */

