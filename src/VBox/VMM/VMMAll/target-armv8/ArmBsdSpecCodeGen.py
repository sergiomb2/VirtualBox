#!/usr/bin/env python
# -*- coding: utf-8 -*-
# $Id$

"""
ARM BSD / OpenSource specification code generator.
"""

from __future__ import print_function;

__copyright__ = \
"""
Copyright (C) 2025 Oracle and/or its affiliates.

This file is part of VirtualBox base platform packages, as
available from https://www.virtualbox.org.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, in version 3 of the
License.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <https://www.gnu.org/licenses>.

SPDX-License-Identifier: GPL-3.0-only
"""
__version__ = "$Revision$"

# Standard python imports.
import argparse;
import collections;
import datetime;
import hashlib;
import operator;
import os;
import re;
import sys;
import time;

# Our imports:
from ArmAst import ArmAstAssignment;
from ArmAst import ArmAstBinaryOp;
from ArmAst import ArmAstBool;
from ArmAst import ArmAstConcat;
from ArmAst import ArmAstCppExpr;
from ArmAst import ArmAstCppStmt;
from ArmAst import ArmAstDotAtom;
from ArmAst import ArmAstField;
from ArmAst import ArmAstFunction;
from ArmAst import ArmAstIdentifier;
from ArmAst import ArmAstIfList;
from ArmAst import ArmAstInteger;
from ArmAst import ArmAstReturn;
from ArmAst import ArmAstSet;
from ArmAst import ArmAstSquareOp;
from ArmAst import ArmAstString;
from ArmAst import ArmAstTypeAnnotation;
from ArmAst import ArmAstUnaryOp;
from ArmAst import ArmAstValue;
import ArmBsdSpec as spec;

# Imports from the parent directory.
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))));
import PyCommonVmm as pycmn;    # pylint: disable=import-error


## Program start time for logging.
g_nsProgStart = int(time.time_ns())


## Mapping from ARM FEAT_xxxx to CPUMFEATURESARMV8 member.
#
# The values are usually member names.  Alternatively, they can be fixed boolean
# values for things that are hardcoded (like mandatory feature, not in the spec).
# The special value -1 can be used as an alternative to False and will cause a
# todo comment to be generated.
#
# Sed script for extracting this stuff from cpum.h (-n option, sort output):
#
# # Match all comment lines with a (FEAT_XXX) in them.
# /[ (]FEAT_[A-Zn].*\*\//!d
#
# # Extract the feature string, quote it for dict key and pad to the value column.
# s,^.*[ (]\(FEAT_[A-Zn][^ )]*\)[ )].*\*\/.*$,'\1':,
# :morepadding
# s/$/ /
# /^................................/!b morepadding
#
# # Load the next line with the value, extract the member name and quote it for dict value.
# N
# s/\n *uint32_t  *\(f[a-zA-Z0-9][a-zA-Z0-9_]*\) * :.*$/'\1',/
# p
#
g_dSpecFeatToCpumFeat = {
    # Mandatory.
    'FEAT_EL0':                     True,
    'FEAT_EL1':                     True,

    # Generated by sed + sort:
    'FEAT_AA32':                    'fAa32',
    'FEAT_AA32BF16':                'fAa32Bf16',
    'FEAT_AA32EL0':                 'fAa32El0',
    'FEAT_AA32EL1':                 'fAa32El1',
    'FEAT_AA32EL2':                 'fAa32El2',
    'FEAT_AA32EL3':                 'fAa32El3',
    'FEAT_AA32HPD':                 'fAa32Hpd',
    'FEAT_AA32I8MM':                'fAa32I8mm',
    'FEAT_AA64':                    'fAa64',
    'FEAT_AA64EL0':                 'fAa64El0',
    'FEAT_AA64EL1':                 'fAa64El1',
    'FEAT_AA64EL2':                 'fAa64El2',
    'FEAT_AA64EL3':                 'fAa64El3',
    'FEAT_ABLE':                    'fAble',
    'FEAT_ADERR':                   'fAderr',
    'FEAT_AdvSIMD':                 'fAdvSimd',
    'FEAT_AES':                     'fAes',
    'FEAT_AFP':                     'fAfp',
    'FEAT_AIE':                     'fAie',
    'FEAT_AMUv1':                   'fAmuV1',
    'FEAT_AMUv1p1':                 'fAmuV1p1',
    'FEAT_ANERR':                   'fAnerr',
    'FEAT_ASID16':                  'fAsid16',
    'FEAT_ASID2':                   'fAsid2',
    'FEAT_ATS1A':                   'fATs1a',
    'FEAT_BBM':                     'fBbm',
    'FEAT_BF16':                    'fBf16',
    'FEAT_BRBE':                    'fBrbe',
    'FEAT_BRBEv1p1':                'fBrbeV1p1',
    'FEAT_BTI':                     'fBti',
    'FEAT_BWE':                     'fBwe',
    'FEAT_BWE2':                    'fBwe2',
    'FEAT_CCIDX':                   'fCcidx',
    'FEAT_CHK':                     'fChk',
    'FEAT_CLRBHB':                  'fClrBhb',
    'FEAT_CMOW':                    'fCmow',
    'FEAT_CMPBR':                   'fCmpBr',
    #'FEAT_CNTSC':                   'fCntsc',              # needs external registers for detection
    'FEAT_CONSTPACFIELD':           'fConstPacField',
    #'FEAT_CP15SDISABLE2':           'fCp15SDisable2', - can't be detected?
    'FEAT_CPA':                     'fCpa',
    'FEAT_CPA2':                    'fCpa2',
    'FEAT_CRC32':                   'fCrc32',
    'FEAT_CSSC':                    'fCssc',
    'FEAT_CSV2':                    'fCsv2',
    'FEAT_CSV2_1p1':                'fCsv21p1',
    'FEAT_CSV2_1p2':                'fCsv21p2',
    'FEAT_CSV2_2':                  'fCvs2_2',
    'FEAT_CSV2_3':                  'fCsv2v3',
    'FEAT_CSV3':                    'fCsv3',
    'FEAT_D128':                    'fD128',
    'FEAT_Debugv8p1':               'fDebugV8p1',
    'FEAT_Debugv8p2':               'fDebugV8p2',
    'FEAT_Debugv8p4':               'fDebugV8p4',
    'FEAT_Debugv8p8':               'fDebugV8p8',
    'FEAT_Debugv8p9':               'fDebugV8p9',
    'FEAT_DGH':                     'fDgh',
    'FEAT_DIT':                     'fDit',
    #'FEAT_DoPD':                    'fDopd',               # needs external registers for detection
    'FEAT_DotProd':                 'fDotProd',
    'FEAT_DoubleFault':             'fDoubleFault',
    'FEAT_DoubleFault2':            'fDoubleFault2',
    'FEAT_DoubleLock':              'fDoubleLock',
    'FEAT_DPB':                     'fDpb',
    'FEAT_DPB2':                    'fDpb2',
    'FEAT_E0PD':                    'fE0Pd',
    'FEAT_E2H0':                    'fE2H0',
    'FEAT_E3DSE':                   'fE3Dse',
    'FEAT_EBEP':                    'fEbep',
    'FEAT_EBF16':                   'fEbf16',
    'FEAT_ECBHB':                   'fEcBhb',
    'FEAT_ECV':                     'fEcv',
    'FEAT_ECV_POFF':                'fEcvPOff',
    #'FEAT_EDHSR':                   'fEdhsr',              # needs external registers for detection
    'FEAT_EL2':                     'fEl2',
    'FEAT_EL3':                     'fEl3',
    'FEAT_EPAC':                    'fEpac',
    'FEAT_ETE':                     'fEte',
    'FEAT_ETEv1p1':                 'fEteV1p1',
    'FEAT_ETEv1p2':                 'fEteV1p2',
    'FEAT_ETEv1p3':                 'fEteV1p3',
    'FEAT_ETMv4':                   'fEtmV4',
    'FEAT_ETMv4p1':                 'fEtmV4p1',
    'FEAT_ETMv4p2':                 'fEtmV4p2',
    'FEAT_ETMv4p3':                 'fEtmV4p3',
    'FEAT_ETMv4p4':                 'fEtmV4p4',
    'FEAT_ETMv4p5':                 'fEtmV4p5',
    'FEAT_ETMv4p6':                 'fEtmV4p6',
    'FEAT_ETS2':                    'fEts2',
    'FEAT_ETS3':                    'fEts3',
    'FEAT_EVT':                     'fEvt',
    'FEAT_ExS':                     'fExs',
    'FEAT_F32MM':                   'fF32mm',
    'FEAT_F64MM':                   'fF64mm',
    'FEAT_F8F16MM':                 'fF8F16mm',
    'FEAT_F8F32MM':                 'fF8F32mm',
    'FEAT_FAMINMAX':                'fFaMinMax',
    'FEAT_FCMA':                    'fFcma',
    'FEAT_FGT':                     'fFgt',
    'FEAT_FGT2':                    'fFgt2',
    'FEAT_FGWTE3':                  'fFgwtE3',
    'FEAT_FHM':                     'fFhm',
    'FEAT_FlagM':                   'fFlagM',
    'FEAT_FlagM2':                  'fFlagM2',
    'FEAT_FP':                      'fFp',
    'FEAT_FP16':                    'fFp16',
    'FEAT_FP8':                     'fFp8',
    'FEAT_FP8DOT2':                 'fFp8Dot2',
    'FEAT_FP8DOT4':                 'fFp8Dot4',
    'FEAT_FP8FMA':                  'fFp8Fma',
    'FEAT_FPAC':                    'fFpac',
    'FEAT_FPACC_SPEC':              'fFpaccSpec',
    'FEAT_FPACCOMBINE':             'fFpacCombine',
    'FEAT_FPMR':                    'fFpmr',
    'FEAT_FPRCVT':                  'fFpRcvt',
    'FEAT_FRINTTS':                 'fFrintts',
    'FEAT_GCS':                     'fGcs',
    'FEAT_GICv3':                   'fGicV3',
    'FEAT_GICv3_NMI':               'fGicV3Nmi',
    'FEAT_GICv3_TDIR':              'fGicV3Tdir',
    'FEAT_GICv3p1':                 'fGicV3p1',
    'FEAT_GICv4':                   'fGicV4',
    'FEAT_GICv4p1':                 'fGicV4p1',
    'FEAT_GTG':                     'fGtg',
    'FEAT_HACDBS':                  'fHacdbs',
    'FEAT_HAFDBS':                  'fHafdbs',
    'FEAT_HAFT':                    'fHaft',
    'FEAT_HBC':                     'fHbc',
    'FEAT_HCX':                     'fHcx',
    'FEAT_HDBSS':                   'fHdbss',
    'FEAT_HPDS':                    'fHpds',
    'FEAT_HPDS2':                   'fHpds2',
    'FEAT_HPMN0':                   'fHpmn0',
    'FEAT_I8MM':                    'fI8mm',
    'FEAT_IDST':                    'fIdst',
    'FEAT_IDTE3':                   'fIdte3',
    'FEAT_IESB':                    'fIesb',
    'FEAT_ITE':                     'fIte',
    'FEAT_IVIPT':                   'fIvipt',
    'FEAT_JSCVT':                   'fJscvt',
    'FEAT_LOR':                     'fLor',
    'FEAT_LPA':                     'fLpa',
    'FEAT_LPA2':                    'fLpa2',
    'FEAT_LRCPC':                   'fLrcpc',
    'FEAT_LRCPC2':                  'fLrcpc2',
    'FEAT_LRCPC3':                  'fLrcpc3',
    'FEAT_LS64':                    'fLs64',
    'FEAT_LS64_ACCDATA':            'fLs64Accdata',
    'FEAT_LS64_V':                  'fLs64V',
    'FEAT_LS64WB':                  'fLs64WB',
    'FEAT_LSE':                     'fLse',
    'FEAT_LSE128':                  'fLse128',
    'FEAT_LSE2':                    'fLse2',
    'FEAT_LSFE':                    'fLsfe',
    'FEAT_LSMAOC':                  'fLsmaoc',
    'FEAT_LSUI':                    'fLsui',
    'FEAT_LUT':                     'fLut',
    'FEAT_LVA':                     'fLva',
    'FEAT_LVA3':                    'fLva3',
    'FEAT_MEC':                     'fMec',
    'FEAT_MixedEnd':                'fMixedEnd',
    'FEAT_MixedEndEL0':             'fMixedEndEl0',
    'FEAT_MOPS':                    'fMops',
    'FEAT_MPAM':                    'fMpam',
    #'FEAT_MPAM_MSC_DCTRL':          'fMpamMscDCtrl',       # needs external registers for detection
    #'FEAT_MPAM_MSC_DOMAINS':        'fMpamMscDomains',     # needs external registers for detection
    'FEAT_MPAM_PE_BW_CTRL':         'fMpamPeBwCtrl',
    'FEAT_MPAMv0p1':                'fMpamV0p1',
    'FEAT_MPAMv1p1':                'fMpamV1p1',
    'FEAT_MTE':                     'fMte',
    'FEAT_MTE_ASYM_FAULT':          'fMteAsymFault',
    'FEAT_MTE_ASYNC':               'fMteAsync',
    'FEAT_MTE_CANONICAL_TAGS':      'fMteCanonicalTags',
    'FEAT_MTE_NO_ADDRESS_TAGS':     'fMteNoAddressTags',
    'FEAT_MTE_PERM':                'fMtePerm',
    #'FEAT_MTE_PERM_S1':             'fMtePermS1', # removed?
    'FEAT_MTE_STORE_ONLY':          'fMteStoreOnly',
    'FEAT_MTE_TAGGED_FAR':          'fMteTaggedFar',
    'FEAT_MTE2':                    'fMte2',
    'FEAT_MTE3':                    'fMte3',
    'FEAT_MTE4':                    'fMte4',
    'FEAT_MTPMU':                   'fMtPmu',
    'FEAT_NMI':                     'fNmi',
    'FEAT_nTLBPA':                  'fNTlbpa',
    'FEAT_NV':                      'fNv',
    'FEAT_NV2':                     'fNv2',
    'FEAT_NV2p1':                   'fNV2p1',
    'FEAT_OCCMO':                   'fOccmo',
    'FEAT_PACIMP':                  'fPacImp',
    'FEAT_PACQARMA3':               'fPacQarma3',
    'FEAT_PACQARMA5':               'fPacQarma5',
    'FEAT_PAN':                     'fPan',
    'FEAT_PAN2':                    'fPan2',
    'FEAT_PAN3':                    'fPan3',
    'FEAT_PAuth':                   'fPAuth',
    'FEAT_PAuth_LR':                'fPAuthLR',
    'FEAT_PAuth2':                  'fPAuth2',
    'FEAT_PCDPHINT':                'fPCDPHint',
    #'FEAT_PCSRv8':                  'fPcsrV8',             # needs external registers for detection
    #'FEAT_PCSRv8p2':                'fPcsrV8p2',           # needs external registers for detection
    #'FEAT_PCSRv8p9':                'fPcsrV8p9',           # needs external registers for detection
    'FEAT_PFAR':                    'fPfar',
    'FEAT_PMULL':                   'fPmull',
    'FEAT_PMUv3':                   'fPmuV3',
    'FEAT_PMUv3_EDGE':              'fPmuV3Edge',
    #'FEAT_PMUv3_EXT':               'fPmuV3Ext',           # difficult to detect
    #'FEAT_PMUv3_EXT32':             'fPmuV3Ext32',         # difficult to detect
    #'FEAT_PMUv3_EXT64':             'fPmuV3Ext64',         # difficult to detect
    'FEAT_PMUv3_ICNTR':             'fPmuV3Icntr',
    'FEAT_PMUv3_SME':               'fPmuV3Sme',
    'FEAT_PMUv3_SS':                'fPmuV3Ss',
    'FEAT_PMUv3_TH':                'fPmuV3Th',
    'FEAT_PMUv3_TH2':               'fPmuV3Th2',
    'FEAT_PMUv3p1':                 'fPmuV3p1',
    'FEAT_PMUv3p4':                 'fPmuV3p4',
    'FEAT_PMUv3p5':                 'fPmuV3p5',
    'FEAT_PMUv3p7':                 'fPmuV3p7',
    'FEAT_PMUv3p8':                 'fPmuV3p8',
    'FEAT_PMUv3p9':                 'fPmuV3p9',
    'FEAT_PRFMSLC':                 'fPrfmSlc',
    'FEAT_RAS':                     'fRas',
    #'FEAT_RASSAv1p1':               'fRassaV1p1',          # difficult to detect
    #'FEAT_RASSAv2':                 'fRasSaV2',            # difficult to detect
    'FEAT_RASv1p1':                 'fRasV1p1',
    'FEAT_RASv2':                   'fRasV2',
    'FEAT_RDM':                     'fRdm',
    'FEAT_RME':                     'fRme',
    'FEAT_RME_GDI':                 'fRmeGdi',
    'FEAT_RME_GPC2':                'fRmeGpc2',
    'FEAT_RME_GPC3':                'fRmeGpc3',
    'FEAT_RNG':                     'fRng',
    'FEAT_RNG_TRAP':                'fRngTrap',
    'FEAT_RPRES':                   'fRpres',
    'FEAT_RPRFM':                   'fRprfm',
    'FEAT_S1PIE':                   'fS1Pie',
    'FEAT_S1POE':                   'fS1Poe',
    'FEAT_S2FWB':                   'fS2Fwb',
    'FEAT_S2PIE':                   'fS2Pie',
    'FEAT_S2POE':                   'fS2Poe',
    'FEAT_S2TGran16K':              'fS2TGran16K',
    'FEAT_S2TGran4K':               'fS2TGran4K',
    'FEAT_S2TGran64K':              'fS2TGran64K',
    'FEAT_SB':                      'fSb',
    'FEAT_SCTLR2':                  'fSctlr2',
    'FEAT_SEBEP':                   'fSebep',
    'FEAT_SEL2':                    'fSecEl2',
    'FEAT_SHA1':                    'fSha1',
    'FEAT_SHA256':                  'fSha256',
    'FEAT_SHA3':                    'fSha3',
    'FEAT_SHA512':                  'fSha512',
    'FEAT_SM3':                     'fSm3',
    'FEAT_SM4':                     'fSm4',
    'FEAT_SME':                     'fSme',
    'FEAT_SME_B16B16':              'fSmeB16B16',
    'FEAT_SME_F16F16':              'fSmeF16F16',
    'FEAT_SME_F64F64':              'fSmeF64F64',
    'FEAT_SME_F8F16':               'fSmeF8F16',
    'FEAT_SME_F8F32':               'fSmeF8F32',
    'FEAT_SME_FA64':                'fSmeFA64',
    'FEAT_SME_I16I64':              'fSmeI16I64',
    'FEAT_SME_LUTv2':               'fSmeLutv2',
    'FEAT_SME_MOP4':                'fSmeMop4',
    'FEAT_SME_TMOP':                'fSmeTmop',
    'FEAT_SME2':                    'fSme2',
    'FEAT_SME2p1':                  'fSme2p1',
    'FEAT_SME2p2':                  'fSme2p2',
    'FEAT_SPE':                     'fSpe',
    'FEAT_SPE_ALTCLK':              'fSpeAltClk',
    'FEAT_SPE_CRR':                 'fSpeCrr',
    'FEAT_SPE_DPFZS':               'fSpeDpfzs',
    'FEAT_SPE_EFT':                 'fSpeEft',
    'FEAT_SPE_EXC':                 'fSpeExc',
    'FEAT_SPE_FDS':                 'fSpeFds',
    'FEAT_SPE_FnE':                 'fSpeFnE',
    'FEAT_SPE_FPF':                 'fSpeFpf',
    'FEAT_SPE_nVM':                 'fSpeNvm',
    'FEAT_SPE_PBT':                 'fSpePbt',
    'FEAT_SPE_SME':                 'fSpeSme',
    'FEAT_SPECRES':                 'fSpecres',
    'FEAT_SPECRES2':                'fSpecres2',
    'FEAT_SpecSEI':                 'fSpecSei',
    'FEAT_SPEv1p1':                 'fSpeV1p1',
    'FEAT_SPEv1p2':                 'fSpeV1p2',
    'FEAT_SPEv1p3':                 'fSpeV1p3',
    'FEAT_SPEv1p4':                 'fSpeV1p4',
    'FEAT_SPEv1p5':                 'fSpev1p5',
    'FEAT_SPMU':                    'fSpmu',
    'FEAT_SPMU2':                   'fSpmu2',
    'FEAT_SSBS':                    'fSsbs',
    'FEAT_SSBS2':                   'fSsbs2',
    'FEAT_SSVE_AES':                'fSsveAes',
    'FEAT_SSVE_BitPerm':            'fSsveBitPerm',
    'FEAT_SSVE_FEXPA':              'fSsveFexpa',
    'FEAT_SSVE_FP8DOT2':            'fSsveFp8Dot2',
    'FEAT_SSVE_FP8DOT4':            'fSsveFp8Dot4',
    'FEAT_SSVE_FP8FMA':             'fSsveFp8Fma',
    'FEAT_STEP2':                   'fStep2',
    'FEAT_SVE':                     'fSve',
    'FEAT_SVE_AES':                 'fSveAes',
    'FEAT_SVE_AES2':                'fSveAes2',
    'FEAT_SVE_B16B16':              'fSveB16B16',
    'FEAT_SVE_BFSCALE':             'fSveBfscale',
    'FEAT_SVE_BitPerm':             'fSveBitPerm',
    'FEAT_SVE_F16F32MM':            'fSveF16F32mm',
    'FEAT_SVE_PMULL128':            'fSvePmull128',
    'FEAT_SVE_SHA3':                'fSveSha3',
    'FEAT_SVE_SM4':                 'fSveSm4',
    'FEAT_SVE2':                    'fSve2',
    'FEAT_SVE2p1':                  'fSve2p1',
    'FEAT_SVE2p2':                  'fSve2p2',
    'FEAT_SYSINSTR128':             'fSysInstr128',
    'FEAT_SYSREG128':               'fSysReg128',
    'FEAT_TCR2':                    'fTcr2',
    'FEAT_TGran16K':                'fTGran16K',
    'FEAT_TGran4K':                 'fTGran4K',
    'FEAT_TGran64K':                'fTGran64K',
    'FEAT_THE':                     'fThe',
    'FEAT_TIDCP1':                  'fTidcp1',
    'FEAT_TLBIOS':                  'fTlbios',
    'FEAT_TLBIRANGE':               'fTlbirange',
    'FEAT_TLBIW':                   'fTlbiW',
    'FEAT_TME':                     'fTme',
    'FEAT_TRBE':                    'fTrbe',
    'FEAT_TRBE_EXC':                'fTrbeExc',
    'FEAT_TRBE_EXT':                'fTrbeExt',
    'FEAT_TRBE_MPAM':               'fTrbeMpam',
    'FEAT_TRBEv1p1':                'fTrbev1p1',
    'FEAT_TRC_SR':                  'fTrcSr',
    'FEAT_TRF':                     'fTrf',
    'FEAT_TTCNP':                   'fTtcnp',
    'FEAT_TTL':                     'fTtl',
    'FEAT_TTST':                    'fTtst',
    'FEAT_TWED':                    'fTwed',
    'FEAT_UAO':                     'fUao',
    'FEAT_UINJ':                    'fUinj',
    'FEAT_VHE':                     'fVhe',
    'FEAT_VMID16':                  'fVmid16',
    'FEAT_VPIPT':                   'fVpipt',
    'FEAT_WFxT':                    'fWfxt',
    'FEAT_XNX':                     'fXnx',
    'FEAT_XS':                      'fXs',

    ## @todo
    'FEAT_SRMASK':                  -1,
};


## Mapping register names to CPUMCTX members.
## The value is: (sName|fReservedValue,)
g_dRegToCpumCtx = {
    'AArch64.PMUSERENR_EL0':    ( 0, ), # Concat uses EN; we don't support it, so report zero.
    'AArch64.AMUSERENR_EL0':    ( 0, ), # We don't support this, so report zero.
    'AArch64.CNTP_CTL_EL0':     ( 0, ), # We don't seem to support this, so report zero.
    'AArch64.GCSCRE0_EL1':      ( 0, ), # FEAT_GCS / ARMv9.4; we don't support this, returning zero for now.
    'AArch64.HCRX_EL2':         ( 0, ), # FEAT_HCX / ARMv8.7; we don't support this, returning zero for now.
    'AArch64.HDFGRTR_EL2':      ( 0, ), # FEAT_FGT / ARMv8.6; we don't support this, returning zero for now.
    'AArch64.HDFGWTR_EL2':      ( 0, ), # FEAT_FGT / ARMv8.6; we don't support this, returning zero for now.
    'AArch64.HFGRTR_EL2':       ( 0, ), # FEAT_FGT / ARMv8.6; we don't support this, returning zero for now.
    'AArch64.HFGWTR_EL2':       ( 0, ), # FEAT_FGT / ARMv8.6; we don't support this, returning zero for now.
    ## @todo 'AArch64.ICC_SRE_EL1': ( '.u64', ), - GIC has debug logging of this, but no handling.
    ## @todo 'AArch64.ICC_SRE_EL2': ( '.u64', ), - GIC lists this in the range, but not sure how to get at any value...
    ## @todo 'AArch64.ICH_HCR_EL2': ( '.u64', ), - This is part of GICv3, but our GIC doesn't mention it.
    ## @todo 'AArch64.MPAM2_EL2':   ( '.u64', ), - FEAT_MPAM / ARMv8.4; not sure if zero is a passable value here...
    ## @todo 'AArch64.MPAMBW2_EL2': ( '.u64', ), - FEAT_MPAM_PE_BW_CTRL / ARMv9.3; ditto.
    ## @todo 'AArch64.MPAMHCR_EL2': ( '.u64', ), - FEAT_MPAM / ARMv8.4; not sure if zero is a passable value here...
    ## @todo 'AArch64.MPAMIDR_EL1': ( '.u64', ), - FEAT_MPAM / ARMv8.4; not sure if zero is a passable value here...
    ## @todo 'AArch64.OSLSR_EL1':        ( 'fOsLck', ),  - this is a bool in our code...
    'AArch64.PMSCR_EL1':        ( 0, ), # FEAT_SPE / ARMv8.1
    ## @todo 'AArch64.PMSELR_EL0':  ( '.u64', ), - FEAT_PMUv3 / ARMv8.0; not sure if zero is a passable value here...
    ## @todo 'AArch64.PMUACR_EL1':  ( '.u64', ), - FEAT_PMUv3p9; not sure if zero is a passable value here...
    ## @todo 'AArch64.SCR_EL3':     ( '.u64', ), - we don't do EL3, so some stuff isn't eliminated properly...
    ## @todo 'AArch64.SPMSELR_EL0': ( '.u64', ), - FEAT_SPMU / ARMv8.8
    ## @todo 'AArch64.TRCIDR0':     ( '.u64', ), - FEAT_ETE / ARMv9.0
    ## @todo 'AArch64.TRCIDR2':     ( '.u64', ), - FEAT_ETE / ARMv9.0
    ## @todo 'AArch64.TRCIDR3':     ( '.u64', ), - FEAT_ETE / ARMv9.0
    ## @todo 'AArch64.TRCIDR4':     ( '.u64', ), - FEAT_ETE / ARMv9.0
    ## @todo 'AArch64.TRCIDR5':     ( '.u64', ), - FEAT_ETE / ARMv9.0
    ## @todo 'AArch64.TRFCR_EL1':   ( '.u64', ), - FEAT_TRF  / ??

    'AArch64.SP_EL0':           ('aSpReg[0].u64',),
    'AArch64.SP_EL1':           ('aSpReg[1].u64',),
    'AArch64.SP_EL2':           ('SpEl2.u64',),

    'AArch64.SPSR_EL1':         ('Spsr.u64',),
    'AArch64.ELR_EL1':          ('Elr.u64',),
    'AArch64.SCTLR_EL1':        ('Sctlr.u64',),
    'AArch64.TCR_EL1':          ('Tcr.u64',),
    'AArch64.TTBR0_EL1':        ('Ttbr0.u64',),
    'AArch64.TTBR1_EL1':        ('Ttbr1.u64',),
    'AArch64.VBAR_EL1':         ('VBar.u64',),
    'AArch64.MDSCR_EL1':        ('Mdscr.u64',),

    'AArch64.DBGBCR0_EL1':      ('aBp[0].Ctrl.u64',),
    'AArch64.DBGBCR1_EL1':      ('aBp[1].Ctrl.u64',),
    'AArch64.DBGBCR2_EL1':      ('aBp[2].Ctrl.u64',),
    'AArch64.DBGBCR3_EL1':      ('aBp[3].Ctrl.u64',),
    'AArch64.DBGBCR4_EL1':      ('aBp[4].Ctrl.u64',),
    'AArch64.DBGBCR5_EL1':      ('aBp[5].Ctrl.u64',),
    'AArch64.DBGBCR6_EL1':      ('aBp[6].Ctrl.u64',),
    'AArch64.DBGBCR7_EL1':      ('aBp[7].Ctrl.u64',),
    'AArch64.DBGBCR8_EL1':      ('aBp[8].Ctrl.u64',),
    'AArch64.DBGBCR9_EL1':      ('aBp[9].Ctrl.u64',),
    'AArch64.DBGBCR10_EL1':     ('aBp[10].Ctrl.u64',),
    'AArch64.DBGBCR11_EL1':     ('aBp[11].Ctrl.u64',),
    'AArch64.DBGBCR12_EL1':     ('aBp[12].Ctrl.u64',),
    'AArch64.DBGBCR13_EL1':     ('aBp[13].Ctrl.u64',),
    'AArch64.DBGBCR14_EL1':     ('aBp[14].Ctrl.u64',),
    'AArch64.DBGBCR15_EL1':     ('aBp[15].Ctrl.u64',),

    'AArch64.DBGBVR0_EL1':      ('aBp[0].Value.u64',),
    'AArch64.DBGBVR1_EL1':      ('aBp[1].Value.u64',),
    'AArch64.DBGBVR2_EL1':      ('aBp[2].Value.u64',),
    'AArch64.DBGBVR3_EL1':      ('aBp[3].Value.u64',),
    'AArch64.DBGBVR4_EL1':      ('aBp[4].Value.u64',),
    'AArch64.DBGBVR5_EL1':      ('aBp[5].Value.u64',),
    'AArch64.DBGBVR6_EL1':      ('aBp[6].Value.u64',),
    'AArch64.DBGBVR7_EL1':      ('aBp[7].Value.u64',),
    'AArch64.DBGBVR8_EL1':      ('aBp[8].Value.u64',),
    'AArch64.DBGBVR9_EL1':      ('aBp[9].Value.u64',),
    'AArch64.DBGBVR10_EL1':     ('aBp[10].Value.u64',),
    'AArch64.DBGBVR11_EL1':     ('aBp[11].Value.u64',),
    'AArch64.DBGBVR12_EL1':     ('aBp[12].Value.u64',),
    'AArch64.DBGBVR13_EL1':     ('aBp[13].Value.u64',),
    'AArch64.DBGBVR14_EL1':     ('aBp[14].Value.u64',),
    'AArch64.DBGBVR15_EL1':     ('aBp[15].Value.u64',),

    'AArch64.DBGWCR0_EL1':      ('aWp[0].Ctrl.u64',),
    'AArch64.DBGWCR1_EL1':      ('aWp[1].Ctrl.u64',),
    'AArch64.DBGWCR2_EL1':      ('aWp[2].Ctrl.u64',),
    'AArch64.DBGWCR3_EL1':      ('aWp[3].Ctrl.u64',),
    'AArch64.DBGWCR4_EL1':      ('aWp[4].Ctrl.u64',),
    'AArch64.DBGWCR5_EL1':      ('aWp[5].Ctrl.u64',),
    'AArch64.DBGWCR6_EL1':      ('aWp[6].Ctrl.u64',),
    'AArch64.DBGWCR7_EL1':      ('aWp[7].Ctrl.u64',),
    'AArch64.DBGWCR8_EL1':      ('aWp[8].Ctrl.u64',),
    'AArch64.DBGWCR9_EL1':      ('aWp[9].Ctrl.u64',),
    'AArch64.DBGWCR10_EL1':     ('aWp[10].Ctrl.u64',),
    'AArch64.DBGWCR11_EL1':     ('aWp[11].Ctrl.u64',),
    'AArch64.DBGWCR12_EL1':     ('aWp[12].Ctrl.u64',),
    'AArch64.DBGWCR13_EL1':     ('aWp[13].Ctrl.u64',),
    'AArch64.DBGWCR14_EL1':     ('aWp[14].Ctrl.u64',),
    'AArch64.DBGWCR15_EL1':     ('aWp[15].Ctrl.u64',),

    'AArch64.DBGWVR0_EL1':      ('aWp[0].Value.u64',),
    'AArch64.DBGWVR1_EL1':      ('aWp[1].Value.u64',),
    'AArch64.DBGWVR2_EL1':      ('aWp[2].Value.u64',),
    'AArch64.DBGWVR3_EL1':      ('aWp[3].Value.u64',),
    'AArch64.DBGWVR4_EL1':      ('aWp[4].Value.u64',),
    'AArch64.DBGWVR5_EL1':      ('aWp[5].Value.u64',),
    'AArch64.DBGWVR6_EL1':      ('aWp[6].Value.u64',),
    'AArch64.DBGWVR7_EL1':      ('aWp[7].Value.u64',),
    'AArch64.DBGWVR8_EL1':      ('aWp[8].Value.u64',),
    'AArch64.DBGWVR9_EL1':      ('aWp[9].Value.u64',),
    'AArch64.DBGWVR10_EL1':     ('aWp[10].Value.u64',),
    'AArch64.DBGWVR11_EL1':     ('aWp[11].Value.u64',),
    'AArch64.DBGWVR12_EL1':     ('aWp[12].Value.u64',),
    'AArch64.DBGWVR13_EL1':     ('aWp[13].Value.u64',),
    'AArch64.DBGWVR14_EL1':     ('aWp[14].Value.u64',),
    'AArch64.DBGWVR15_EL1':     ('aWp[15].Value.u64',),

    'AArch64.APDAKeyLo_EL1':    ('Apda.Low.u64',),
    'AArch64.APDAKeyHi_EL1':    ('Apda.High.u64',),

    'AArch64.APDBKeyLo_EL1':    ('Apdb.Low.u64',),
    'AArch64.APDBKeyHi_EL1':    ('Apdb.High.u64',),

    'AArch64.APGAKeyLo_EL1':    ('Apga.Low.u64',),
    'AArch64.APGAKeyHi_EL1':    ('Apga.High.u64',),

    'AArch64.APIAKeyLo_EL1':    ('Apia.Low.u64',),
    'AArch64.APIAKeyHi_EL1':    ('Apia.High.u64',),

    'AArch64.APIBKeyLo_EL1':    ('Apib.Low.u64',),
    'AArch64.APIBKeyHi_EL1':    ('Apib.High.u64',),

    'AArch64.AFSR0_EL1':        ('Afsr0.u64',),
    'AArch64.AFSR1_EL1':        ('Afsr1.u64',),
    'AArch64.AMAIR_EL1':        ('Amair.u64',),
    'AArch64.CNTKCTL_EL1':      ('CntKCtl.u64',),
    'AArch64.CONTEXTIDR_EL1':   ('ContextIdr.u64',),
    'AArch64.CPACR_EL1':        ('Cpacr.u64',),
    'AArch64.CSSELR_EL1':       ('Csselr.u64',),
    'AArch64.ESR_EL1':          ('Esr.u64',),
    'AArch64.FAR_EL1':          ('Far.u64',),
    'AArch64.MAIR_EL1':         ('Mair.u64',),
    'AArch64.PAR_EL1':          ('Par.u64',),
    'AArch64.TPIDRRO_EL0':      ('TpIdrRoEl0.u64',),
    'AArch64.TPIDR_EL0':        ('aTpIdr[0].u64',),
    'AArch64.TPIDR_EL1':        ('aTpIdr[1].u64',),
    'AArch64.MDCCINT_EL1':      ('MDccInt.u64',),
    'AArch64.ACTLR_EL1':        ('Actlr.u64',),

    'AArch64.CNTHCTL_EL2':      ('CntHCtlEl2.u64',),
    'AArch64.CNTHP_CTL_EL2':    ('CntHpCtlEl2.u64',),
    'AArch64.CNTHP_CVAL_EL2':   ('CntHpCValEl2.u64',),
    'AArch64.CNTHP_TVAL_EL2':   ('CntHpTValEl2.u64',),
    'AArch64.CNTVOFF_EL2':      ('CntVOffEl2.u64',),
    'AArch64.CPTR_EL2':         ('CptrEl2.u64',),
    'AArch64.ELR_EL2':          ('ElrEl2.u64',),
    'AArch64.ESR_EL2':          ('EsrEl2.u64',),
    'AArch64.FAR_EL2':          ('FarEl2.u64',),
    'AArch64.HCR_EL2':          ('HcrEl2.u64',),
    'AArch64.HPFAR_EL2':        ('HpFarEl2.u64',),
    'AArch64.MAIR_EL2':         ('MairEl2.u64',),
    'AArch64.MDCR_EL2':         ('MdcrEl2.u64',),
    'AArch64.SCTLR_EL2':        ('SctlrEl2.u64',),
    'AArch64.SPSR_EL2':         ('SpsrEl2.u64',),
    'AArch64.TCR_EL2':          ('TcrEl2.u64',),
    'AArch64.TPIDR_EL2':        ('TpidrEl2.u64',),
    'AArch64.TTBR0_EL2':        ('Ttbr0El2.u64',),
    'AArch64.TTBR1_EL2':        ('Ttbr1El2.u64',),
    'AArch64.VBAR_EL2':         ('VBarEl2.u64',),
    'AArch64.VMPIDR_EL2':       ('VMpidrEl2.u64',),
    'AArch64.VPIDR_EL2':        ('VPidrEl2.u64',),
    'AArch64.VTCR_EL2':         ('VTcrEl2.u64',),
    'AArch64.VTTBR_EL2':        ('VTtbrEl2.u64',),
    'AArch64.FPCR':             ('fpcr',),
    'AArch64.FPSR':             ('fpsr',),
    'AArch64.CNTV_CTL_EL0':     ('CntvCtlEl0',),
    'AArch64.CNTV_CVAL_EL0':    ('CntvCValEl0',),
};


#
# Decoder structure helpers.
#

## Populated by --decoder-hint0
g_dDecoderFilterDepth0 = { };

## Populated by --decoder-hint1
g_ddDecoderFilterDepth1 = { };


class MaskZipper(object):
    """
    This is mainly a class for putting static methods relating to mask
    packing and unpack.
    """

    def __init__(self):
        pass;

    @staticmethod
    def compileAlgo(fMask):
        """
        Returns an with instructions for extracting the bits from the mask into
        a compacted form. Each array entry is an array/tuple of source bit [0],
        destination bit [1], and bit counts [2].
        """
        aaiAlgo   = [];
        iSrcBit   = 0;
        iDstBit   = 0;
        while fMask > 0:
            # Skip leading zeros.
            cSkip    = (fMask & -fMask).bit_length() - 1;
            #assert (fMask & ((1 << cSkip) - 1)) == 0 and ((fMask >> cSkip) & 1), 'fMask=%#x cSkip=%d' % (fMask, cSkip)
            iSrcBit += cSkip;
            fMask  >>= cSkip;

            # Calculate leading ones the same way.
            cCount = (~fMask & -~fMask).bit_length() - 1;
            #assert (fMask & ((1 << cCount) - 1)) == ((1 << cCount) - 1) and (fMask & (1 << cCount)) == 0

            # Append to algo list.
            aaiAlgo.append((iSrcBit, iDstBit, (1 << cCount) - 1));

            # Advance.
            iDstBit += cCount;
            iSrcBit += cCount;
            fMask  >>= cCount;
        return aaiAlgo;

    @staticmethod
    def compileAlgoLimited(fMask):
        """
        Version of compileAlgo that returns an empty list if there are
        more than three sections.
        """
        #assert fMask;

        #
        # Chunk 0:
        #

        # Skip leading zeros.
        iSrcBit0 = (fMask & -fMask).bit_length() - 1;
        fMask  >>= iSrcBit0;
        # Calculate leading ones the same way.
        cCount0  = (~fMask & -~fMask).bit_length() - 1;
        fMask  >>= cCount0;
        if not fMask:
            return [(iSrcBit0, 0, (1 << cCount0) - 1)];

        #
        # Chunk 1:
        #

        # Skip leading zeros.
        cSrcGap1 = (fMask & -fMask).bit_length() - 1;
        fMask  >>= cSrcGap1;
        # Calculate leading ones the same way.
        cCount1  = (~fMask & -~fMask).bit_length() - 1;
        fMask  >>= cCount1;
        if not fMask:
            return [ (iSrcBit0, 0, (1 << cCount0) - 1),
                     (iSrcBit0 + cCount0 + cSrcGap1, cCount0, (1 << cCount1) - 1)];

        #
        # Chunk 2:
        #

        # Skip leading zeros.
        cSrcGap2 = (fMask & -fMask).bit_length() - 1;
        fMask  >>= cSrcGap2;
        # Calculate leading ones the same way.
        cCount2  = (~fMask & -~fMask).bit_length() - 1;
        fMask  >>= cCount2;
        if not fMask:
            iSrcBit1 = iSrcBit0 + cCount0 + cSrcGap1;
            return [ (iSrcBit0, 0, (1 << cCount0) - 1),
                     (iSrcBit1, cCount0, (1 << cCount1) - 1),
                     (iSrcBit1 + cCount1 + cSrcGap2, cCount0 + cCount1, (1 << cCount2) - 1), ];

        # Too many fragments.
        return [];

    @staticmethod
    def compileAlgoFromList(aiOrderedBits):
        """
        Returns an with instructions for extracting the bits from the mask into
        a compacted form. Each array entry is an array/tuple of source bit [0],
        destination bit [1], and mask (shifted to pos 0) [2].
        """
        aaiAlgo = [];
        iDstBit = 0;
        i       = 0;
        while i < len(aiOrderedBits):
            iSrcBit = aiOrderedBits[i];
            cCount  = 1;
            i      += 1;
            while i < len(aiOrderedBits) and aiOrderedBits[i] == iSrcBit + cCount:
                cCount += 1;
                i      += 1;
            aaiAlgo.append([iSrcBit, iDstBit, (1 << cCount) - 1])
            iDstBit += cCount;
        return aaiAlgo;

    @staticmethod
    def algoToBitList(aaiAlgo):
        aiRet = [];
        for iSrcBit, _, fMask in aaiAlgo:
            cCount = fMask.bit_count();
            aiRet += [iSrcBit + i for i in range(cCount)];
        return aiRet;

    @staticmethod
    def zipMask(uValue, aaiAlgo):
        idxRet = 0;
        for iSrcBit, iDstBit, fMask in aaiAlgo:
            idxRet |= ((uValue >> iSrcBit) & fMask) << iDstBit;
        return idxRet;

    @staticmethod
    def __zipMask1(uValue, aaiAlgo):
        iSrcBit, _, fMask = aaiAlgo[0];
        return (uValue >> iSrcBit) & fMask;

    @staticmethod
    def __zipMask2(uValue, aaiAlgo):
        iSrcBit0, _,        fMask0 = aaiAlgo[0];
        iSrcBit1, iDstBit1, fMask1 = aaiAlgo[1];
        return ((uValue >> iSrcBit0) & fMask0) | (((uValue >> iSrcBit1) & fMask1) << iDstBit1);

    @staticmethod
    def __zipMask3(uValue, aaiAlgo):
        iSrcBit0, _,        fMask0 = aaiAlgo[0];
        iSrcBit1, iDstBit1, fMask1 = aaiAlgo[1];
        iSrcBit2, iDstBit2, fMask2 = aaiAlgo[2];
        return ((uValue >> iSrcBit0) & fMask0) \
             | (((uValue >> iSrcBit1) & fMask1) << iDstBit1) \
             | (((uValue >> iSrcBit2) & fMask2) << iDstBit2);

    @staticmethod
    def algoToZipLambda(aaiAlgo, fAlgoMask, fCompileIt = True):
        assert aaiAlgo;
        if not fCompileIt:
            if len(aaiAlgo) == 1: return MaskZipper.__zipMask1;
            if len(aaiAlgo) == 2: return MaskZipper.__zipMask2;
            if len(aaiAlgo) == 3: return MaskZipper.__zipMask3;
            return MaskZipper.zipMask;
        # Compile it:
        sBody = '';
        for iSrcBit, iDstBit, fMask in aaiAlgo:
            if sBody:
                sBody += ' | ';
            assert iSrcBit >= iDstBit;
            if iDstBit == 0:
                if iSrcBit == 0:
                    sBody += '(uValue & %#x)' % (fMask,);
                else:
                    sBody += '((uValue >> %u) & %#x)' % (iSrcBit, fMask);
            else:
                sBody += '((uValue >> %u) & %#x)' % (iSrcBit - iDstBit, fMask << iDstBit);
        _ = fAlgoMask
        #sFn = 'zipMaskCompiled_%#010x' % (fAlgoMask,);
        #sFn = 'zipMaskCompiled';
        #dTmp = {};
        #exec('def %s(uValue,_): return %s' % (sFn, sBody), globals(), dTmp);
        #return dTmp[sFn];
        return eval('lambda uValue,_: ' + sBody);

    @staticmethod
    def unzipMask(uValue, aaiAlgo):
        fRet = 0;
        for iSrcBit, iDstBit, fMask in aaiAlgo:
            fRet |= ((uValue >> iDstBit) & fMask) << iSrcBit;
        return fRet;

    @staticmethod
    def __unzipMask1(uValue, aaiAlgo):
        return uValue << aaiAlgo[0][0];

    @staticmethod
    def __unzipMask2(uValue, aaiAlgo):
        iSrcBit0, _,        fMask0 = aaiAlgo[0];
        iSrcBit1, iDstBit1, fMask1 = aaiAlgo[1];
        return ((uValue & fMask0) << iSrcBit0) | (((uValue >> iDstBit1) & fMask1) << iSrcBit1);

    @staticmethod
    def __unzipMask3(uValue, aaiAlgo):
        iSrcBit0, _,        fMask0 = aaiAlgo[0];
        iSrcBit1, iDstBit1, fMask1 = aaiAlgo[1];
        iSrcBit2, iDstBit2, fMask2 = aaiAlgo[2];
        return ((uValue & fMask0) << iSrcBit0) \
             | (((uValue >> iDstBit1) & fMask1) << iSrcBit1) \
             | (((uValue >> iDstBit2) & fMask2) << iSrcBit2);

    @staticmethod
    def algoToUnzipLambda(aaiAlgo, fAlgoMask, fCompileIt = True):
        assert aaiAlgo;
        if not fCompileIt:
            if len(aaiAlgo) == 1: return MaskZipper.__unzipMask1;
            if len(aaiAlgo) == 2: return MaskZipper.__unzipMask2;
            if len(aaiAlgo) == 3: return MaskZipper.__unzipMask3;
            return MaskZipper.unzipMask;
        # Compile it:
        sBody = '';
        for iSrcBit, iDstBit, fMask in aaiAlgo:
            if sBody:
                sBody += ' | ';
            if iDstBit == 0:
                if iSrcBit == 0:
                    sBody += '(uIdx & %#x)' % (fMask,);
                else:
                    sBody += '((uIdx & %#x) << %u)' % (fMask, iSrcBit);
            else:
                sBody += '((uIdx << %u) & %#x)' % (iSrcBit - iDstBit, fMask << iSrcBit);

        _ = fAlgoMask
        #dTmp = {};
        #sFn = 'unzipMaskCompiled';
        #sFn = 'unzipMaskCompiled_%#010x' % (fAlgoMask,);
        #exec('def %s(uIdx,_): return %s' % (sFn, sBody), globals(), dTmp);
        #return dTmp[sFn];
        return eval('lambda uIdx,_: ' + sBody);


class MaskIterator(object):
    """ Helper class for DecoderNode.constructNextLevel(). """

    ## Maximum number of mask sub-parts.
    # Lower number means fewer instructions required to convert it into an index.
    # This is implied by the code in MaskZipper.compileAlgoLimited.
    kcMaxMaskParts = 3

    def __init__(self, fMask, cMinTableSizeInBits, cMaxTableSizeInBits, fMaskNotDoneYet):
        self.fMask               = fMask;
        self.aaiAlgo             = MaskZipper.compileAlgo(fMask);
        self.fCompactMask        = MaskZipper.zipMask(fMask, self.aaiAlgo);
        self.fnExpandMask        = MaskZipper.algoToUnzipLambda(self.aaiAlgo, fMask,
                                                                self.fCompactMask.bit_count() >= 8);
        self.cMinTableSizeInBits = cMinTableSizeInBits;
        self.cMaxTableSizeInBits = cMaxTableSizeInBits;
        self.fCompactMaskNotDoneYet = MaskZipper.zipMask(fMaskNotDoneYet, self.aaiAlgo);
        #print('debug: fMask=%#x -> fCompactMask=%#x aaiAlgo=%s' % (fMask, self.fCompactMask, self.aaiAlgo));
        #self.cReturned           = 0;

    def __iter__(self):
        return self;

    def __next__(self):
        fCompactMask           = self.fCompactMask;
        fCompactMaskNotDoneYet = self.fCompactMaskNotDoneYet;
        cMinTableSizeInBits    = self.cMinTableSizeInBits
        cMaxTableSizeInBits    = self.cMaxTableSizeInBits
        while fCompactMask != 0:
            if fCompactMask & fCompactMaskNotDoneYet:
                cCurBits = fCompactMask.bit_count();
                if cMinTableSizeInBits <= cCurBits <= cMaxTableSizeInBits:
                    fMask = self.fnExpandMask(fCompactMask, self.aaiAlgo);
                    aaiMaskAlgo = MaskZipper.compileAlgoLimited(fMask);
                    if aaiMaskAlgo:
                        #assert aaiMaskAlgo == MaskZipper.compileAlgo(fMask), \
                        #    '%s vs %s' % (aaiMaskAlgo, MaskZipper.compileAlgo(fMask));
                        #self.cReturned += 1;
                        self.fCompactMask = fCompactMask - 1;
                        return (fMask, cCurBits, aaiMaskAlgo);
            fCompactMask -= 1;
        self.fCompactMask = 0;
        #print('MaskIterator: fMask=%#x -> %u items returned' % (self.fMask, self.cReturned));
        raise StopIteration;


class DecoderNode(object):

    ## The absolute maximum table size in bits index by the log2 of the instruction count.
    kacMaxTableSizesInBits = (
        2,      # [2^0 =     1] =>     4
        4,      # [2^1 =     2] =>    16
        5,      # [2^2 =     4] =>    32
        6,      # [2^3 =     8] =>    64
        7,      # [2^4 =    16] =>   128
        7,      # [2^5 =    32] =>   128
        8,      # [2^6 =    64] =>   256
        9,      # [2^7 =   128] =>   512
        10,     # [2^8 =   256] =>  1024
        11,     # [2^9 =   512] =>  2048
        12,     # [2^10 = 1024] =>  4096
        13,     # [2^11 = 2048] =>  8192
        14,     # [2^12 = 4096] => 16384
        14,     # [2^13 = 8192] => 16384
        15,     # [2^14 =16384] => 32768
    );

    kfChildMaskOpcodeValueIf          = 0x7fffffff;
    kfChildMaskMultipleOpcodeValueIfs = 0xffffffff;

    class TooExpensive(Exception):
        def __init__(self):
            Exception.__init__(self, None);

    def __init__(self, aoInstructions, fCheckedMask, fCheckedValue):
        #assert (~fCheckedMask & fCheckedValue) == 0;
        #for idxInstr, oInstr in enumerate(aoInstructions):
        #    assert ((oInstr.fFixedValue ^ fCheckedValue) & fCheckedMask & oInstr.fFixedMask) == 0, \
        #            '%s: fFixedValue=%#x fFixedMask=%#x fCheckedValue=%#x fCheckedMask=%#x -> %#x\naoInstructions: len=%s\n %s' \
        #            % (idxInstr, oInstr.fFixedValue, oInstr.fFixedMask, fCheckedValue, fCheckedMask,
        #               (oInstr.fFixedValue ^ fCheckedValue) & fCheckedMask & oInstr.fFixedMask,
        #               len(aoInstructions),
        #               '\n '.join(['%s%s: %#010x/%#010x %s' % ('*' if i == idxInstr else ' ', i,
        #                                                       oInstr2.fFixedValue, oInstr2.fFixedMask, oInstr2.sName)
        #                           for i, oInstr2 in enumerate(aoInstructions[:idxInstr+8])]));

        self.aoInstructions     = aoInstructions;   ##< The instructions at this level.
        self.fCheckedMask       = fCheckedMask;     ##< The opcode bit mask covered thus far.
        self.fCheckedValue      = fCheckedValue;    ##< The value that goes with fCheckedMask.
        self.fChildMask         = 0;                ##< The mask used to separate the children.
        self.dChildren          = {};               ##< Children, sparsely populated by constructNextLevel().

    @staticmethod
    def popCount(uValue):
        cBits = 0;
        while uValue:
            cBits += 1;
            uValue &= uValue - 1;
        return cBits;

    s_uLogLine = 0;  # pylint: disable=invalid-name
    @staticmethod
    def dprint(uDepth, sMsg):
        msNow = (time.time_ns() - g_nsProgStart) // 1000000;
        print('%u.%03u: %u: debug/%u: %s%s' % (msNow // 1000, msNow % 1000, DecoderNode.s_uLogLine, uDepth, '  ' * uDepth, sMsg));
        DecoderNode.s_uLogLine += 1;

    def constructNextLevel(self, uDepth, uMaxCost): # pylint: disable=too-many-locals,too-many-statements
        """
        Recursively constructs the
        """
        if uDepth == 0:
            for i, oInstr in enumerate(self.aoInstructions):
                self.dprint(uDepth, '%4u: %s' % (i, oInstr.toString(cchName = 32),));

        #
        # Special cases: 4 or fewer entries.
        #
        cInstructions = len(self.aoInstructions)
        if cInstructions <= 4:
            assert not self.dChildren;
            uCost = 0;
            # Special case: 1 instruction - leaf.
            if cInstructions <= 1:
                if self.aoInstructions[0].fFixedMask & ~self.fCheckedMask != 0:
                    self.fChildMask = DecoderNode.kfChildMaskOpcodeValueIf;
                    uCost = 16;                                                         # 16 = kCostOpcodeValueIf
                else:
                    assert self.fChildMask == 0;

            # Special case: 2, 3 or 4 instructions - use a sequence of 'if ((uOpcode & fFixedMask) == fFixedValue)' checks.
            else:
                self.fChildMask = DecoderNode.kfChildMaskMultipleOpcodeValueIfs;
                uCost = 32 * cInstructions * 2;                                         # 32 = kCostMultipleOpcodeValueIfs
            return uCost;

        #
        # The cost of one indirect call is 256, so just bail if we don't have
        # the budget for any of that.
        #
        if uMaxCost <= 256:                                                             # 256 = kCostIndirectCall
            raise DecoderNode.TooExpensive();
        if uDepth > 5:                                                                  #   5 = kMaxDepth
            raise DecoderNode.TooExpensive();

        #
        # Do an inventory of the fixed masks used by the instructions.
        #
        dMaskCounts  = collections.Counter();
        fCheckedMask = self.fCheckedMask;    # (Cache it as a local variable for speed.)
        for oInstr in self.aoInstructions:
            dMaskCounts[oInstr.fFixedMask & ~fCheckedMask] += 1;
        #assert 0 not in dMaskCounts or dMaskCounts[0] <= 1, \
        #        'dMaskCounts=%s cInstructions=%s\n%s' % (dMaskCounts, cInstructions, self.aoInstructions);
        # 0x00011c00 & 0xfffee000  = 0x0 (0)

        #
        # HACK ALERT! For level 0 and 1 we offer ways to insert hints to reduce
        #             the runtime, since it's tedious to wait for 30 min for
        #             each code tweak...  See --decoder-hint0 and --decoder-hint1.
        #
        dSpeedupFilter = None;
        if uDepth <= 1:
            if uDepth == 1:
                dSpeedupFilter = g_ddDecoderFilterDepth1.get('%x/%x' % (self.fCheckedMask, self.fCheckedValue), None);
            elif g_dDecoderFilterDepth0:
                dSpeedupFilter = g_dDecoderFilterDepth0;

        #
        # Whether to bother compiling the mask zip/unzip functions.
        #
        # The goal here is to keep the {built-in method builtins.eval} line far
        # away from top of the profiler stats, while at the same time keeping the
        # __zipMaskN and __unzipMaskN methods from taking up too much time.
        #
        fCompileMaskZip   = cInstructions >= 256;
        fCompileMaskUnzip = cInstructions >= 32; #?

        #
        # Work thru the possible masks and test out the variations (brute force style).
        #
        uCostBest        = uMaxCost;
        cChildrenBits    = 0;
        fChildrenBest    = 0;
        dChildrenBest    = {};

        fMaskNotDoneYet  = 0xffffffff;
        fCheckedValue    = self.fCheckedValue; # (Cache it as a local variable for speed.)
        iOuterLoop       = -1;
        for fOrgMask, cOccurences in dMaskCounts.most_common(3):
            iOuterLoop += 1;

            # Determin the max and min table sizes (in bits) based on the instructions using the mask.
            cMinTableSizeInBits = cOccurences.bit_length() - 1;
            if (1 << cMinTableSizeInBits) < cOccurences:
                cMinTableSizeInBits += 1;
            cMaxTableSizeInBits = self.kacMaxTableSizesInBits[cMinTableSizeInBits]; # Not quite sure about this...
            cMinTableSizeInBits -= 1;

            if uDepth <= 2:
                self.dprint(uDepth,
                            '%s Start/%u: %#010x (%u) - %u/%u instructions - tab size %u-%u; fChecked=%#x/%#x uCostBest=%#x'
                            % (('=' if iOuterLoop == 0 else '-') * 5, iOuterLoop, fOrgMask,
                               self.popCount(fOrgMask), cOccurences, cInstructions, cMinTableSizeInBits, cMaxTableSizeInBits,
                               fCheckedValue, fCheckedMask, uCostBest,));

            # Skip pointless stuff and things we've already covered.
            if cOccurences >= 2 and fOrgMask > 0 and fOrgMask != 0xffffffff and (fOrgMask & fMaskNotDoneYet) != 0:
                #
                # Step 1: Brute force relevant mask variations and pick a few masks.
                #
                # The MaskIterator skips masks that are too wide, too fragmented or
                # already covered.
                #
                # The cost calculation is mainly based on distribution vs table size,
                # trying to favor masks with more target slots.
                #
                dCandidates = {};
                for fMask, cMaskBits, aaiMaskToIdxAlgo in MaskIterator(fOrgMask, cMinTableSizeInBits, cMaxTableSizeInBits,
                                                                       fMaskNotDoneYet):
                    #if uDepth <= 2:
                    #    self.dprint(uDepth, '1>> fMask=%#010x cMaskBits=%s aaiMaskToIdxAlgo=%s...'
                    #                         % (fMask, cMaskBits, aaiMaskToIdxAlgo));
                    #assert cMaskBits <= cMaxTableSizeInBits;

                    # HACK ALERT! Skip the mask if we have a selection filter and it isn't in it.
                    if dSpeedupFilter and fMask not in dSpeedupFilter:
                        continue;

                    # Calculate base cost and check it against uCostBest before continuing.
                    uCostTmp    = 256;                                                  # 256 = kCostIndirectCall
                    uCostTmp   += (len(aaiMaskToIdxAlgo) - 1) * 2;                      #   2 = kCostPerExtraIndexStep
                    if uCostTmp >= uCostBest:
                        #if uDepth <= 2:
                        #    self.dprint(uDepth, '!!! %#010x too expensive #1: %#x vs %#x' % (fMask, uCostTmp, uCostBest));
                        continue;

                    # Compile the indexing/unindexing functions.
                    fnToIndex   = MaskZipper.algoToZipLambda(aaiMaskToIdxAlgo, fMask, fCompileMaskZip);

                    # Insert the instructions into the temporary table.
                    daoTmp = collections.defaultdict(list);
                    for oInstr in self.aoInstructions:
                        idx = fnToIndex(oInstr.fFixedValue, aaiMaskToIdxAlgo);
                        #self.dprint(uDepth, '%#010x -> %#05x %s' % (oInstr.fFixedValue, idx, oInstr.sName));
                        fNonFixedMatches = ~oInstr.fFixedMask & fMask;
                        if fNonFixedMatches == 0:
                            daoTmp[idx].append(oInstr);
                        else:
                            fIdxNonFixedMatches  = fnToIndex(fNonFixedMatches, aaiMaskToIdxAlgo);
                            cBitsNonFixedMatches = fNonFixedMatches.bit_count();
                            if cBitsNonFixedMatches < 8:
                                idxStep         = fIdxNonFixedMatches & (~fIdxNonFixedMatches + 1);
                                idxInstrMask    = fnToIndex(oInstr.fFixedMask, aaiMaskToIdxAlgo);
                                idxInstrLast    = idx | fIdxNonFixedMatches;
                                for idx2 in range(idx, idxInstrLast + idxStep, idxStep):
                                    if (idx2 & idxInstrMask) == idx:
                                        daoTmp[idx2].append(oInstr);
                            else:
                                aaiNonFixedAlgo = MaskZipper.compileAlgo(fIdxNonFixedMatches);
                                fnNonFixedUnzip = MaskZipper.algoToUnzipLambda(aaiNonFixedAlgo, fIdxNonFixedMatches);
                                for idx3 in range(MaskZipper.zipMask(fIdxNonFixedMatches, aaiNonFixedAlgo) + 1):
                                    idx2 = idx | fnNonFixedUnzip(idx3, aaiNonFixedAlgo);
                                    daoTmp[idx2].append(oInstr);

                    ## @todo Account for entires causing instruction duplication...
                    ##       Perhaps by summing up the number of instructions for the next level?
                    cEffTmpSize = len(daoTmp);

                    # Reject anything that ends up putting all the stuff in a single slot.
                    if cEffTmpSize <= 1:
                        #if uDepth <= 2: self.dprint(uDepth, '!!! bad distribution #1: fMask=%#x' % (fMask,));
                        continue;

                    # Add cost for poor average distribution.
                    rdAvgLen = float(cInstructions) / cEffTmpSize;
                    if rdAvgLen > 1.2:
                        uCostTmp += int(rdAvgLen * 8)
                        if uCostTmp >= uCostBest:
                            #if uDepth <= 2:
                            #    self.dprint(uDepth, '!!! %#010x too expensive #2: %#x vs %#x (rdAvgLen=%s)'
                            #                        % (fMask, uCostTmp, uCostBest, rdAvgLen));
                            continue;

                    # Add the cost for unused entries under reasonable table population.
                    cNominalFill = 1 << (cMaskBits - 1); # 50% full or better is great.
                    if cEffTmpSize < cNominalFill:
                        uCostTmp += ((cNominalFill - cEffTmpSize) * 2);                 # 2 = kCostUnusedTabEntry
                        if uCostTmp >= uCostBest:
                            #if uDepth <= 2:
                            #    self.dprint(uDepth, '!!! %#010x too expensive #3: %#x vs %#x' % (fMask, uCostTmp, uCostBest));
                            continue;

                    # Record it as a candidate.
                    dCandidates[uCostTmp] = (fMask, cMaskBits, aaiMaskToIdxAlgo, daoTmp);
                    if len(dCandidates) > 64:
                        dOld = dCandidates;
                        dCandidates = { uKey:dOld[uKey] for uKey in sorted(dCandidates.keys())[:4] };
                        del dOld;

                #
                # Step 2: Process the top 4 candidates.
                #
                for uCostTmp in sorted(dCandidates.keys())[:4]:
                    fMask, cMaskBits, aaiMaskToIdxAlgo, daoTmp = dCandidates[uCostTmp];

                    #if uDepth <= 2:
                    #    self.dprint(uDepth, '2>> fMask=%#010x cMaskBits=%s aaiMaskToIdxAlgo=%s #daoTmp=%s...'
                    #                         % (fMask, cMaskBits, aaiMaskToIdxAlgo, len(daoTmp),));
                    #assert cMaskBits <= cMaxTableSizeInBits;

                    # Construct decoder nodes from the aaoTmp lists, construct sub-levels and calculate costs.
                    fnFromIndex  = MaskZipper.algoToUnzipLambda(aaiMaskToIdxAlgo, fMask, fCompileMaskUnzip);
                    dChildrenTmp = {};
                    try:
                        for idx, aoInstrs in daoTmp.items():
                            oChild = DecoderNode(aoInstrs,
                                                 fCheckedMask  | fMask,
                                                 fCheckedValue | fnFromIndex(idx, aaiMaskToIdxAlgo));
                            dChildrenTmp[idx] = oChild;
                            uCostTmp += oChild.constructNextLevel(uDepth + 1, uCostBest - uCostTmp);
                            if uCostTmp >= uCostBest:
                                break;
                    except DecoderNode.TooExpensive:
                        #if uDepth <= 2:
                        #    self.dprint(uDepth, '!!! %#010x too expensive #4: %#x+child vs %#x' % (fMask, uCostTmp, uCostBest));
                        continue;

                    # Is this mask better than the previous?
                    if uCostTmp < uCostBest:
                        if uDepth <= 2:
                            self.dprint(uDepth,
                                        '+++ %s best!  %#010x (%u) uCost=%#x; %u ins in %u slots (previous %#010x / %#x) ...'
                                        % ('New' if cChildrenBits else '1st', fMask, cMaskBits, uCostTmp,
                                           cInstructions, len(dChildrenTmp), fChildrenBest, uCostBest, ));
                        uCostBest      = uCostTmp;
                        cChildrenBits  = cMaskBits;
                        fChildrenBest  = fMask;
                        dChildrenBest  = dChildrenTmp;
                    #elif uDepth <= 2:
                    #    self.dprint(uDepth, '!!! %#010x too expensive #5: %#x vs %#x' % (fMask, uCostTmp, uCostBest));

                # Note that we've covered all the permutations in the given mask.
                fMaskNotDoneYet &= ~fOrgMask;

        # Drop it if too expensive.
        if uCostBest >= uMaxCost:
            raise DecoderNode.TooExpensive();

        if dChildrenBest is None:
            print('warning! No solution! depth=%u #Instruction=%u' % (uDepth, cInstructions));
            raise Exception('fixme')

        #assert fChildrenBest.bit_count() == cChildrenBits;
        #assert len(dChildrenBest) <= (1 << cChildrenBits)
        if uDepth <= 2:
            self.dprint(uDepth,
                        '===== Final: fMask=%#010x (%u) uCost=%#x #Instructions=%u in %u slots over %u entries...'
                        % (fChildrenBest, cChildrenBits, uCostBest, cInstructions, len(dChildrenBest), 1 << cChildrenBits));

        # Done.
        self.fChildMask = fChildrenBest;
        self.dChildren  = dChildrenBest;

        return uCostBest;

    def setInstrProps(self, uDepth):
        """
        Sets the fDecoderLeafCheckNeeded instruction property.
        """
        if not self.dChildren:
            assert len(self.aoInstructions) != 1 or self.fChildMask in (0, DecoderNode.kfChildMaskOpcodeValueIf);
            assert len(self.aoInstructions) == 1 or self.fChildMask == DecoderNode.kfChildMaskMultipleOpcodeValueIfs;
            for oInstr in self.aoInstructions:
                oInstr.fDecoderLeafCheckNeeded = self.fChildMask == DecoderNode.kfChildMaskOpcodeValueIf;
        else:
            for oChildNode in self.dChildren.values():
                oChildNode.setInstrProps(uDepth + 1);

    def getFuncName(self, sInstrSet, uDepth):
        """
        Returns the function name at the specific depth.
        """
        if not sInstrSet:
            sInstrSet = self.aoInstructions[0].getInstrSetName()
        if self.dChildren or len(self.aoInstructions) > 1:
            return 'iemDecode%s_%08x_%08x_%u' % (sInstrSet, self.fCheckedMask, self.fCheckedValue, uDepth,);
        return 'iemDecode%s_%s' % (sInstrSet, self.aoInstructions[0].getCName(),);


#
# System Register Code Morphing.
#

class SysRegAccessorInfo(object):
    """ Info about an accessor we're emitting code for. """
    def __init__(self, oAccessor, oReg, sEnc):
        self.oAccessor  = oAccessor     # type: ArmAccessorSystem
        self.oReg       = oReg;
        self.sEnc       = sEnc;
        self.oCode      = None;
        # Stats for the code generator.
        self.cCallsToIsFeatureImplemented = 0;
        self.cInstructionReferences       = 0;
        self.cInstrEssenceRefs            = 0;  # References to uInstrEssence (idSysReg + idGprReg + direction)
        self.cAssignmentsWithUnresolvedRegs = 0;  # Number of unresolved system register assignment reference.
        ## This is updated by morphCodeToC() and will be zero the code is ready for compilation.
        self.cIncompleteNodes             = -1;


class SysRegGeneratorBase(object):
    """ Base class for the system register access code generators. """

    kdELxToNum = { 'EL0': 0, 'EL1': 1, 'EL2': 2, 'EL3': 3, }

    def __init__(self, sInstr, sFuncPrefix):
        self.sInstr         = sInstr;
        self.sFuncPrefix    = sFuncPrefix;
        self.aoInfo         = []        # type: List[SysRegAccessorInfo]
        self.cComplete      = 0;
        self.cIncomplete    = 0;
        self.cUnresolvedRegs = 0;       # Number of info items with unresolved registers.

    def generateOneHandler(self, oInfo):
        return [ '', '/// @todo %s / %s' % (self.sInstr, oInfo.sEnc,) ];

    def generateMainFunction(self):
        return [ '', '/// @todo %s main function' % (self.sInstr,) ];

    def isA64Instruction(self):
        return self.sInstr.startswith('A64');

    def getRegStateName(self):
        return 'AArch64' if self.isA64Instruction() else 'AArch32';

    def checkCConversionCallback(self, oNode, oInfo):
        """ Walker callback used by morphCodeToC() to look for nodes that aren't suitable for C. """
        if isinstance(oNode, ArmAstBinaryOp):
            if ArmAstBinaryOp.kdOps[oNode.sOp] in (ArmAstBinaryOp.ksOpTypeCompare, ArmAstBinaryOp.ksOpTypeLogical,
                                                   ArmAstBinaryOp.ksOpTypeArithmetical, ArmAstBinaryOp.ksOpTypeBitwise):
                return True;
        elif isinstance(oNode, ArmAstReturn):
            if oNode.oValue:
                return True;
        elif isinstance(oNode, (ArmAstBool, ArmAstCppExpr, ArmAstCppStmt, ArmAstIfList, ArmAstInteger, ArmAstUnaryOp,
                                ArmAstAssignment, self.VBoxAstCppConcat)):
            return True;

        oInfo.cIncompleteNodes += 1;
        return True;

    def morphCodeToC(self, oInfo):
        """ Morphs the accessor code and assigns the result to self.oCode """
        assert oInfo.oCode is None;
        oInfo.oCode = self.transformCodePass2(oInfo, self.transformCodePass1(oInfo, oInfo.oAccessor.oAccess.clone()));

        # Update the completion status.
        oInfo.cIncompleteNodes = 0;
        oInfo.oCode.walk(self.checkCConversionCallback, oInfo);
        return True;

    #
    # Pass 1 - Expanding calls & code elimination.
    #

    kdAstForFunctionsWithoutArguments = {
        'EL2Enabled': # HaveEL(EL2) && (!Have(EL3) || SCR_curr[].NS || IsSecureEL2Enabled())
        ArmAstBinaryOp(ArmAstFunction('HaveEL', [ArmAstIdentifier('EL2'),]),
                                     '&&',
                                     ArmAstBinaryOp.orListToTree([
            ArmAstUnaryOp('!', ArmAstFunction('HaveEL', [ArmAstIdentifier('EL3'),])),
            ArmAstDotAtom([ArmAstIdentifier('SCR_curr'), ArmAstIdentifier('NS')]), # SCR_curr is SCR or SCR_EL3.
            ArmAstFunction('IsSecureEL2Enabled', []),
        ])),
    };

    def transformCodePass1_HaveAArch64(self):
        """ Pass 1: The HaveAArch64() must be true if we're in a A64 instruction handler. """
        if self.isA64Instruction():
            return ArmAstBool(True);
        return ArmAstFunction('IsFeatureImplemented', [ArmAstIdentifier('FEAT_AA64')]);

    def transformCodePass1_HaveEL(self, oNode):
        """ Pass 1: HaveEL(ELx) - Translate it into the corresponding feature checks. """
        if oNode.aoArgs[0].isMatchingIdentifier('EL3'):
            return ArmAstBool(False); # EL3 is not implemented.
            #return ArmAstFunction('IsFeatureImplemented', [ArmAstIdentifier('FEAT_EL3')]); ## @todo EL3
        if oNode.aoArgs[0].isMatchingIdentifier('EL2'):
            return ArmAstFunction('IsFeatureImplemented', [ArmAstIdentifier('FEAT_EL2')]);
        if oNode.aoArgs[0].isMatchingIdentifier('EL1') or oNode.aoArgs[0].isMatchingIdentifier('EL0'):
            return ArmAstBool(True); # EL0 and EL1 are mandatory.
        raise Exception('Unexpected HaveEL call: %s' % (oNode.toString(),));

    def transformCodePass1_ELIsInHost(self, oNode):
        """ Pass 1: ELIsInHost(ELx) - Translate this into appropriate AST. """
        if oNode.aoArgs[0].isMatchingIdentifier('EL0') or oNode.aoArgs[0].isMatchingIdentifier('EL2'):
            ## @todo skipping the LEUsingAArch32(EL2) check
            oCommon = ArmAstBinaryOp.andListToTree([
                ArmAstFunction('IsFeatureImplemented', [ArmAstIdentifier('FEAT_VHE')]),
                ArmAstFunction('EL2Enabled', []),
                ArmAstBinaryOp(ArmAstUnaryOp('!', ArmAstFunction('IsFeatureImplemented', [ArmAstIdentifier('FEAT_E2H0')])),
                               '||', ArmAstField('E2H', 'HCR_EL2')),
            ]);
            if oNode.aoArgs[0].isMatchingIdentifier('EL0'):
                return ArmAstBinaryOp(oCommon, '&&', ArmAstField('TGE', 'HCR_EL2'));
            return oCommon;
        if oNode.aoArgs[0].isMatchingIdentifier('EL3') or oNode.aoArgs[0].isMatchingIdentifier('EL1'):
            return ArmAstBool(False); # Only EL0 and EL2 can be in hosted. mode.
        raise Exception('Unexpected ELIsInHost call: %s' % (oNode.toString(),));

    def transformCodePass1_IsFeatureImplemented(self, oNode):
        """ Pass 1: IsFeatureImplemented - replace with False for features we just don't implement. """
        if len(oNode.aoArgs) != 1 or not isinstance(oNode.aoArgs[0], ArmAstIdentifier):
            raise Exception('Unexpected: %s' % (oNode.toString(),));
        ## @todo EL3
        if oNode.aoArgs[0].sName in ('FEAT_AA64EL3', 'FEAT_AA32EL3', 'FEAT_EL3', 'FEAT_RME',
                                     'FEAT_MEC', # This feature implies FEAT_RME, which we don't implement because of no EL3.
                                     'FEAT_SEL2', 'FEAT_Secure', # No secure state w/o EL3...
                                     'FEAT_FGT2', # We don't have any of the associated registers like HDFGRTR2 yet.
                                     ):
            return ArmAstBool(False);

        # Some stuff that is true (probably unused):
        if oNode.aoArgs[0].sName in ('FEAT_AA64',) and self.isA64Instruction():
            return ArmAstBool(True);
        if oNode.aoArgs[0].sName in ('FEAT_EL0', 'FEAT_EL1',):
            return ArmAstBool(True);
        return oNode;

    def transformCodePass1_IsCurrentSecurityState(self, oNode):
        """ Pass 1: IsCurrentSecurityState(SS_Realm), IsCurrentSecurityState(SS_Secure). """
        if len(oNode.aoArgs) == 1 and isinstance(oNode.aoArgs[0], ArmAstIdentifier):
            if oNode.aoArgs[0].sName == 'SS_Realm':
                # Realm requires EL3. ## @todo EL3
                return ArmAstBool(False);
            if oNode.aoArgs[0].sName == 'SS_Secure':
                # SS_Secure requires EL3, unless SecureOnlyImplemeation() is true. ## @todo EL3
                return ArmAstBool(False);
            if oNode.aoArgs[0].sName == 'SS_NonSecure':
                # Without EL3, everything is non-secure.
                return ArmAstBool(True);
        raise Exception('Unexpected: %s' % (oNode.toString(),));

    kasImpDefBoolRetTrue = (
    );
    kaoReImpDefBoolRetTrue = (
        re.compile('^ID_.+ trapped by HCR_EL2\\..*$'),  # e.g. ID_AA64ISAR2_EL1 trapped by HCR_EL2.TID3
    );
    kasImpDefBoolRetFalse = (
        'Trapped by MDCR_EL2.TDOSA',                    # Play it safe and don't trap.
        'IMPLEMENTED_ACTLR_ELx accessor behavior',      # We don't have ACTLR_EL2 or ACTLRMASK_EL2, so False suits us best here.
    );
    kaoReImpDefBoolRetFalse= (
    );

    def transformCodePass1_ImpDefBool(self, oNode):
        """ Pass 1: ImpDefBool("blah blah"). """
        if len(oNode.aoArgs) == 1 and isinstance(oNode.aoArgs[0], ArmAstString):
            sValue = oNode.aoArgs[0].sValue;
            # Exact matches.
            for sCandidate in self.kasImpDefBoolRetTrue:
                if sValue == sCandidate:
                    return ArmAstBool(True);
            for sCandidate in self.kasImpDefBoolRetFalse:
                if sValue == sCandidate:
                    return ArmAstBool(False);
            # Regular expression matches.
            for oRe in self.kaoReImpDefBoolRetTrue:
                if oRe.match(sValue):
                    return ArmAstBool(True);
            for oRe in self.kaoReImpDefBoolRetFalse:
                if oRe.match(sValue):
                    return ArmAstBool(False);
            return oNode;
        raise Exception('Unexpected: %s' % (oNode.toString(),));

    def transformCodePass1_TypeAnnotation(self, oNode, oInfo):
        """ Pass 1: REG_NAME = (bits(0x40)) UNKNOWN; Implementation specific behavior. """
        cBitsWidth = -1;
        if oNode.oType.isMatchingFunctionCall('bits', int):
            cBitsWidth = oNode.oType.aoArgs[0].getIntegerOrValue();
            if cBitsWidth not in (32, 64):
                raise Exception('Unexpected type width: %s' % (oNode.toString(),));

        # For now, just return zero for all of these. If we need anything
        # else, we can determin the context from oInfo.
        _ = oInfo;
        return ArmAstInteger(0, cBitsWidth);

    def transformCodePass1_AArch64_SystemAccessTrap(self, oNode, oInfo): # pylint: disable=invalid-name
        """ Pass 1: AArch64_SystemAccessTrap(EL2,0x18) and such. """
        if len(oNode.aoArgs) == 2:
            idxEl  = self.kdELxToNum.get(oNode.aoArgs[0].getIdentifierName());
            iClass = oNode.aoArgs[1].getIntegerValue();
            if idxEl is not None and iClass is not None:
                assert idxEl > 0;
                if iClass == 0:
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrapUnknown(pVCpu, %s)' % (idxEl,), cBitsWidth = 32));
                if iClass == 7 and self.isA64Instruction():
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrapAdvSimdFpAccessA64(pVCpu, %s)'
                                                       % (idxEl,), cBitsWidth = 32));
                if iClass == 7 and not self.isA64Instruction():
                    oInfo.cInstructionReferences += 1;
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrapAdvSimdFpAccess(pVCpu, %u, u32Instr)'
                                                      % (idxEl,), cBitsWidth = 32));
                if iClass == 20:
                    oInfo.cInstrEssenceRefs += 1;
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrap128Bit(pVCpu, %s, uInstrEssence)'
                                                      % (idxEl,), cBitsWidth = 32));
                if iClass == 24:
                    oInfo.cInstrEssenceRefs += 1;
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrap(pVCpu, %s, uInstrEssence)'
                                                      % (idxEl,), cBitsWidth = 32));
                if iClass == 25:
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrapSme(pVCpu, %s)' % (idxEl,), cBitsWidth = 32));
                if iClass == 29:
                    return ArmAstReturn(ArmAstCppExpr('iemRaiseSystemAccessTrapSme(pVCpu, %s)' % (idxEl,), cBitsWidth = 32));
        raise Exception('Unexpected: %s' % (oNode.toString(),));


    def transformCodePass1Callback(self, oNode, fEliminationAllowed, oInfo, aoStack):
        """
        Callback for pass 1: Code flow adjustments; Optimizations.
        """
        if isinstance(oNode, ArmAstIfList):
            # If we have a complete series of PSTATE.EL == ELx checks,
            # turn the final one into an else case to help compilers make
            # better sense of the code flow.
            if len(oNode.aoIfConditions) >= 3 and not oNode.oElseStatement: ## @todo EL3
                aidxEl = [-1, -1, -1, -1];
                for idxCond, oCond in enumerate(oNode.aoIfConditions):
                    if isinstance(oCond, ArmAstBinaryOp):
                        if oCond.sOp == '==':
                            if oCond.oLeft.isMatchingDotAtom('PSTATE', 'EL'):
                                idxEl = self.kdELxToNum.get(oCond.oRight.getIdentifierName(), -1);
                                if idxEl >= 0:
                                    assert aidxEl[idxEl] == -1;
                                    aidxEl[idxEl] = idxCond;
                assert aidxEl[3] == -1; ## todo EL3
                if aidxEl[0] >= 0 and aidxEl[1] >= 0 and aidxEl[2] >= 0:
                    # We've found checks for each of the 4 EL levels.  Convert the last one into the else.
                    idxLast = max(aidxEl);
                    assert idxLast + 1 == len(oNode.aoIfStatements); # There shall not be anything after the final EL check.
                    oNode.oElseStatement = oNode.aoIfStatements[idxLast];
                    oNode.aoIfConditions = oNode.aoIfConditions[:idxLast];
                    oNode.aoIfStatements = oNode.aoIfStatements[:idxLast];

            # If the first condition is true, just use the corresponding statement.
            if oNode.aoIfConditions and oNode.aoIfConditions[0].isBoolAndTrue():
                return oNode.aoIfStatements[0];

            # Iff there is an else statement, eliminate any identical conditional
            # code blocks immediately preceding it.
            if oNode.oElseStatement and oNode.aoIfStatements:
                cIfStmts = len(oNode.aoIfStatements);
                while cIfStmts > 0 and oNode.oElseStatement.isSame(oNode.aoIfStatements[cIfStmts - 1]):
                    cIfStmts -= 1;
                if cIfStmts < len(oNode.aoIfStatements):
                    oNode.aoIfConditions = oNode.aoIfConditions[:cIfStmts];
                    oNode.aoIfStatements = oNode.aoIfStatements[:cIfStmts];
            if oNode.oElseStatement and not oNode.aoIfStatements:
                return oNode.oElseStatement;

        elif isinstance(oNode, ArmAstBinaryOp):
            # EL3 not implemented, so eliminate PSTATE.EL == 3 and similar. ## @todo EL3
            if oNode.oLeft.isMatchingDotAtom('PSTATE', 'EL'):
                if oNode.oRight.isMatchingIdentifier('EL3'):
                    if oNode.sOp in ('==', '>='):
                        return ArmAstBool(False);
                    if oNode.sOp in ('!=', '<'):
                        return ArmAstBool(True);
                elif oNode.sOp == '>' and oNode.oRight.isMatchingIdentifier('EL2'): # PSTATE.EL > EL2.
                    return ArmAstBool(False);

            # This isn't 100% safe, better do it later on when we generate the C code.
            ## Simplify boolean fields checks.
            #if isinstance(oNode.oLeft, ArmAstField) and isinstance(oNode.oRight, ArmAstValue):
            #    if oNode.oRight.getWidth(None) == 1:
            #        oReg = spec.g_ddoAllArmRegistersByStateByName[oNode.oLeft.sState][oNode.oLeft.sName]; # ArmRegister
            #        aoFields = oReg.daoFields.get(oNode.oLeft.sField); # List[ArmFieldsBase]
            #        if (    aoFields
            #            and len(aoFields[0].aoRanges) == 1
            #            and aoFields[0].aoRanges[0].cBitsWidth == 1
            #            and (   len(aoFields) == 1
            #                 or (    isinstance(aoFields[0].oParent, spec.ArmFieldsConditionalField)
            #                     and len(aoFields[0].oParent.aoRanges) == 1
            #                     and aoFields[0].oParent.aoRanges[0].cBitsWidth == 1))):
            #            if oNode.sOp == '==' and oNode.oRight.sValue == "'1'":
            #                return oNode.oLeft;
            #            if oNode.sOp == '==' and oNode.oRight.sValue == "'0'":
            #                return ArmAstUnaryOp('!', oNode.oLeft);
            #            if oNode.sOp == '!=' and oNode.oRight.sValue == "'0'":
            #                return oNode.oLeft;
            #            if oNode.sOp == '!=' and oNode.oRight.sValue == "'1'":
            #                return ArmAstUnaryOp('!', oNode.oLeft);

        elif isinstance(oNode, ArmAstFunction):
            # Since we don't implement any external debug state (no EDSCR.STATUS),
            # the Halted() and HaltingAllowed() functions always returns False.
            # Eliminate them.
            if (   oNode.isMatchingFunctionCall('Halted')
                or oNode.isMatchingFunctionCall('HaltingAllowed')):
                return ArmAstBool(False);

            # The EL3SDDUndefPriority() and EL3SDDUndef() can likewise be eliminated,
            # as they requires Halted() to be true and EDSCR.SDD to be set.
            if (   oNode.isMatchingFunctionCall('EL3SDDUndefPriority')
                or oNode.isMatchingFunctionCall('EL3SDDUndef')):
                return ArmAstBool(False);

            if oNode.sName == 'HaveAArch64':
                return self.transformCodePass1_HaveAArch64();
            if oNode.sName == 'HaveEL':
                return self.transformCodePass1_HaveEL(oNode);
            if oNode.sName == 'ELIsInHost':
                return self.transformCodePass1(oInfo, self.transformCodePass1_ELIsInHost(oNode));
            if oNode.sName == 'IsFeatureImplemented':
                return self.transformCodePass1_IsFeatureImplemented(oNode);
            if oNode.sName == 'IsCurrentSecurityState':
                return self.transformCodePass1_IsCurrentSecurityState(oNode);
            if oNode.sName == 'ImpDefBool':
                return self.transformCodePass1_ImpDefBool(oNode);

            if oNode.sName == 'AArch64_SystemAccessTrap':
                return self.transformCodePass1_AArch64_SystemAccessTrap(oNode, oInfo);

            # Generic mapping of functions without any arguments:
            if len(oNode.aoArgs) == 0 and oNode.sName in self.kdAstForFunctionsWithoutArguments:
                oNode = self.kdAstForFunctionsWithoutArguments[oNode.sName].clone();
                return self.transformCodePass1(oInfo, oNode);

        elif isinstance(oNode, ArmAstDotAtom):
            # Rewrite lazy ones into Field accesses to avoid duplicating code..
            if len(oNode.aoValues) == 2:
                sReg   = oNode.aoValues[0].getIdentifierName();
                sField = oNode.aoValues[1].getIdentifierName();
                if sReg and sReg != 'PSTATE' and sField:
                    return ArmAstField(sField, sReg, self.getRegStateName());

        elif isinstance(oNode, ArmAstValue):
            # Convert non-wildcard Values.Value nodes into integer nodes with specific width.
            (fValue, _, fWildcard, cBitsWidth) = oNode.getValueDetails();
            if fWildcard == 0:
                return ArmAstInteger(fValue, cBitsWidth);

        elif isinstance(oNode, ArmAstTypeAnnotation):
            if aoStack and isinstance(aoStack[-1], ArmAstAssignment):
                # Typically these are 'REG_NAME = (bits(0x40)) UNKNOWN';
                return self.transformCodePass1_TypeAnnotation(oNode, oInfo);

        _ = fEliminationAllowed;
        return oNode;

    def transformCodePass1(self, oInfo, oCode):
        """ Code transformation pass 1: Code flow adjustments; Optimizations. """
        return oCode.transform(self.transformCodePass1Callback, True, oInfo, []);

    #
    # Pass 2 - C++ translation.
    #

    @staticmethod
    def isIdRegisterEncoding(oEncoding):
        """
        Checks if oEncoding (ArmRegEncoding) is for a known ID register and
        CPUM handleds by lookup.
        """
        # Note! This must match SUPDrv.cpp and CPUMAllCpuId.cpp...
        if (   oEncoding.compareCStyle(3, 0,  0,     range(8), None) == 0 # ID block
            or oEncoding.compareCStyle(3, 0,  5,            3,    0) == 0 # ERRIDR_EL1
            or oEncoding.compareCStyle(3, 0,  9,            9,    7) == 0 # PMSIDR_EL1
            or oEncoding.compareCStyle(3, 0,  9,           10,    7) == 0 # PMBIDR_EL1
            or oEncoding.compareCStyle(3, 0,  9,           11,    7) == 0 # TRBIDR_EL1
            or oEncoding.compareCStyle(3, 0,  9,           14,    6) == 0 # PMMIR_EL1
            or oEncoding.compareCStyle(3, 0, 10,            4,    5) == 0 # MPAMBWIDR_EL1
            or oEncoding.compareCStyle(3, 1,  0,            0,    4) == 0 # GMID_EL1
            or oEncoding.compareCStyle(3, 1,  0,            0,    6) == 0 # SMIDR_EL1
            or oEncoding.compareCStyle(2, 1,  0, range(8, 16),    7) == 0 # TRCIDR[0-7]
            or oEncoding.compareCStyle(2, 1,  0,     range(6),    6) == 0 # TRCIDR[8-13]
            or oEncoding.compareCStyle(2, 1,  7,           15,    6) == 0 # TRCDEVARCH
            ):
            return True;
        return False;

    def lookupRegisterField(self, sState, sRegisterName, sField, sWhatFor, fWarnOnly = False):
        """
        Helper to lookup a register field, returning (oReg, oField, sAccessExpr|fReservedValue).
        Raises exceptions if not found or too complicated.
        """
        oReg = spec.g_ddoAllArmRegistersByStateByName[sState].get(sRegisterName); # ArmRegister
        if not oReg:
            raise Exception('%s: Register "%s" not found (field "%s" lookup)' % (sWhatFor, sRegisterName, sField,));

        aoFields = oReg.daoFields.get(sField); # List[ArmFieldsBase]
        if not aoFields:
            oXcpt = Exception('%s: Field "%s" not found in register "%s"' % (sWhatFor, sField, sRegisterName,));
            if fWarnOnly: print('warning: %s' % (oXcpt)); return (None, None, None);
            raise oXcpt;

        tCpumCtxInfo = g_dRegToCpumCtx.get('%s.%s' % (sState, sRegisterName));
        if tCpumCtxInfo:
            oAccessExprOrInt = 'pVCpu->cpum.GstCtx.' + tCpumCtxInfo[0] if isinstance(tCpumCtxInfo[0], str) else tCpumCtxInfo[0];
        else:
            if sRegisterName == 'OSLSR_EL1' and sState == 'AArch64' and sField == 'OSLK':
                return (oReg, spec.ArmFieldsField(None, [spec.ArmRange(0, 1),], 'OSLK'),
                        'pVCpu->cpum.GstCtx.fOsLck'); # HACK ALERT: boolean field

            # If this is an ID register, we must use CPUMCpuIdLookupSysReg() to access it.
            oAccessExprOrInt = None;
            for oAccessor in oReg.aoAccessors:
                if isinstance(oAccessor, spec.ArmAccessorSystem):
                    if oAccessor.oEncoding.sAsmValue == sRegisterName:
                        if self.isIdRegisterEncoding(oAccessor.oEncoding):
                            oAccessExprOrInt = oAccessor.oEncoding.getSysRegIdCreate();
                            break;
            if not oAccessExprOrInt:
                oXcpt = Exception('%s: No CPUMCTX mapping for register %s.%s (looking up field %s)'
                                  % (sWhatFor, sState, sRegisterName, sField,));
                if fWarnOnly: print('warning: %s' % (oXcpt)); return (None, None, None);
                raise oXcpt;
            oAccessExprOrInt = 'CPUMCpuIdLookupSysReg(pVCpu, %s)' % (oAccessExprOrInt,);

        #
        # Iff this is an conditional field, there may be more than one entry in
        # aoFields and these all are relative to the ArmFieldsConditionalField
        # parent.  So, we just check that it's a simple one and return the
        # parent instaed of the children in aoFields.
        #
        oField = aoFields[-1]; # ArmFieldsBase
        if (    isinstance(oField.oParent, spec.ArmFieldsConditionalField)
            and len(oField.oParent.aoRanges)  == 1
            and len(oField.aoRanges)          == 1
            and oField.aoRanges[0].cBitsWidth == oField.oParent.aoRanges[0].cBitsWidth
            and oField.aoRanges[0].iFirstBit  == 0):
            oField = oField.oParent; # ArmFieldsConditionalField
            if oField.sName is None:
                oField.sName = sField; # HACK ALERT!!
            return (oReg, oField, oAccessExprOrInt,);

        # Try deal with multiple register views depending on context by check
        # if the field being accessed has the same place in all contexts.
        # CPTR_EL2.TCPAC is an example of this.
        if (    len(aoFields) > 1
            and not isinstance(oField.oParent, spec.ArmFieldsConditionalField)
            and len(aoFields[0].aoRanges) == 1):
            fSame = True;
            for idxField in range(1, len(aoFields)):
                fSame = (    fSame
                         and len(aoFields[idxField].aoRanges) == 1
                         and aoFields[idxField].aoRanges[0].isEqualTo(aoFields[0].aoRanges[0]));
            if fSame:
                aoFields = aoFields[:1];

        if len(aoFields) != 1 or isinstance(oField.oParent, spec.ArmFieldsConditionalField):
            oXcpt = Exception('%s: Ambigious register field in %s: %s (%s)'
                              % (sWhatFor, sRegisterName, sField,
                                 ['%s:%s (parent=%s:%s)'
                                  % (type(oField).__name__, oField.toString(),
                                     type(oField.oParent).__name__, oField.oParent.toString(),)
                                  for oField in aoFields] ));
            if fWarnOnly: print('warning: %s' % (oXcpt)); return (None, None, None);
            raise oXcpt;


        if len(oField.aoRanges) != 1:
            raise Exception('%s: Distributed register field in Concat() argument list: %s (%s)'
                            % (sWhatFor, sField, oField.toString(),));

        #print('reg.field: %s.%s' % (oReg.sName, oField.sName));
        return (oReg, oField, oAccessExprOrInt,);


    def transformCodePass2_IsFeatureImplemented(self, oNode, oInfo):
        """ Pass 2: IsFeatureImplemented(FEAT_xxxx) -> pGstFeats->fXxxx. """
        if len(oNode.aoArgs) == 1 and isinstance(oNode.aoArgs[0], ArmAstIdentifier):
            sFeatureNm   = oNode.aoArgs[0].sName;
            sCpumFeature = g_dSpecFeatToCpumFeat.get(sFeatureNm, None);
            if sCpumFeature is None:
                raise Exception('Unknown IsFeatureImplemented parameter: %s (see g_dSpecFeatToCpumFeat)' % (sFeatureNm));
            if isinstance(sCpumFeature, str):
                oInfo.cCallsToIsFeatureImplemented += 1;
                return ArmAstCppExpr('pGstFeats->%s' % (sCpumFeature,), cBitsWidth = 1);
            if sCpumFeature is True:  return 'true /*%s*/' % (sFeatureNm,);
            if sCpumFeature is False: return 'false /*%s*/' % (sFeatureNm,);
            return ArmAstCppExpr('false /** @todo pGstFeats->%s */' % (sFeatureNm,), cBitsWidth = 1);
        raise Exception('Unexpected IsFeatureImplemented arguments: %s' % (oNode.aoArgs,));

    def transformCodePass2_EffectiveHCR_EL2_NVx(self, oNode, oInfo): # pylint: disable=invalid-name
        """ Pass 2: EffectiveHCR_EL2_NVx() -> helper call. """
        if len(oNode.aoArgs) == 0:
            oInfo.cCallsToIsFeatureImplemented += 1;
            return ArmAstCppExpr('iemGetEffHcrEl2NVx(pVCpu, pGstFeats)', cBitsWidth = 3);
        raise Exception('Unexpected IsFeatureImplemented arguments: %s' % (oNode.aoArgs,));


    class VBoxAstCppConcatEntry(object):
        """ An entry in a concat value list. """
        def __init__(self, oOrgValue, cBitsWidth, fValue = None, sAccessExpr = None, oField = None, iFirstBit = -1):
            self.oOrgValue  = oOrgValue # type: ArmAstFunction | ArmAstValue | ArmAstField | ArmAstDotAtom | ArmAstConcat
            ## Fixed field value or None.
            self.fValue     = fValue;
            ## Either a CPUMCTX field access expression or a getter function call expression. Usually resulting in uint64_t.
            self.sAccessExpr = sAccessExpr  # type: str | None
            ## The field details.
            self.oField     = oField    # type: spec.ArmFieldsBase
            ## The number of bits wide the field is.
            self.cBitsWidth = cBitsWidth;
            ## The position in the result.
            self.iFirstBit  = iFirstBit;

        def clone(self):
            return SysRegGeneratorBase.VBoxAstCppConcatEntry(self.oOrgValue, self.cBitsWidth, fValue = self.fValue,
                                                             sAccessExpr = self.sAccessExpr, oField = self.oField,
                                                             iFirstBit = self.iFirstBit);

    class VBoxAstCppConcat(ArmAstCppExpr):
        """ Converted ArmAstConcat. """
        def __init__(self, aoInfoEntries, oOriginal):
            ArmAstCppExpr.__init__(self, oOriginal.toString(), aoInfoEntries[0].iFirstBit + aoInfoEntries[0].cBitsWidth);
            self.aoInfoEntries = aoInfoEntries # type: List[VBoxAstCppConcatEntry]

            # Convert the info items to C++ code.
            asExprs = [];
            i       = 0;
            fFixed  = 0;
            while i < len(aoInfoEntries):
                oInfoEntry = aoInfoEntries[i];
                if oInfoEntry.fValue is not None:
                    fFixed |= oInfoEntry.fValue << oInfoEntry.iFirstBit;
                else:
                    assert oInfoEntry.sAccessExpr;
                    assert oInfoEntry.oField;
                    sNames      = oInfoEntry.oField.sName;
                    iFirstBit   = oInfoEntry.oField.aoRanges[0].iFirstBit;
                    cBitsWidth  = oInfoEntry.oField.aoRanges[0].cBitsWidth;
                    #print('debug/concat: i=%s %uL%u: %s/%uL%u -> %s' % (i, oInfoEntry.iFirstBit, oInfoEntry.cBitsWidth, sNames,
                    #                                                    iFirstBit, cBitsWidth, oInfoEntry.sAccessExpr));
                    while (    i + 1 < len(aoInfoEntries)
                           and aoInfoEntries[i + 1].sAccessExpr is oInfoEntry.sAccessExpr):
                        iCurFirstBit  = aoInfoEntries[i + 1].oField.aoRanges[0].iFirstBit;
                        cCurBitsWidth = aoInfoEntries[i + 1].oField.aoRanges[0].cBitsWidth;
                        if iCurFirstBit + cCurBitsWidth != iFirstBit:
                            break;
                        i += 1;
                        oInfoEntry = aoInfoEntries[i];
                        #print('debug/concat: i=%s %uL%u: %s/%uL%u ++' % (i, oInfoEntry.iFirstBit, oInfoEntry.cBitsWidth,
                        #                                                 oInfoEntry.oField.sName, iCurFirstBit, cCurBitsWidth));
                        iFirstBit   = iCurFirstBit;
                        cBitsWidth += cCurBitsWidth;
                        sNames     += ',' + aoInfoEntries[i].oField.sName;

                    fMask = ((1 << cBitsWidth) - 1) << iFirstBit;
                    if iFirstBit == oInfoEntry.iFirstBit:
                        asExprs.append('(%s & UINT64_C(%#x)/*%s*/)' % (oInfoEntry.sAccessExpr, fMask, sNames));
                    elif iFirstBit > oInfoEntry.iFirstBit:
                        asExprs.append('((%s & UINT64_C(%#x)/*%s*/) >> %d)'
                                       % (oInfoEntry.sAccessExpr, fMask, sNames, iFirstBit - oInfoEntry.iFirstBit));
                    else:
                        asExprs.append('((%s & UINT64_C(%#x)/*%s*/) << %d)'
                                       % (oInfoEntry.sAccessExpr, fMask, sNames, oInfoEntry.iFirstBit - iFirstBit));
                i += 1;
            if fFixed != 0:
                asExprs.append('UINT64_C(%#x)' % (fFixed,));

            self.asExprs = asExprs;
            self.sExpr   = '(%s)' % (' | '.join(asExprs),) if len(asExprs) > 1 else asExprs[0];

        def toStringEx(self, sLang = None, cchMaxWidth = 120):
            _ = sLang;
            if len(self.sExpr) <= cchMaxWidth:
                return self.sExpr;
            return '(  %s)' % ('\n | '.join(self.asExprs),);

        def areAllFromSameRegister(self):
            """ Checks if all the entries are from the same register or are zero. """
            sAccessExpr = self.aoInfoEntries[0].sAccessExpr;
            idx         = 1;
            while idx < len(self.aoInfoEntries) and not sAccessExpr:
                sAccessExpr = self.aoInfoEntries[idx].sAccessExpr;
                idx += 1;
            if sAccessExpr:
                for oInfoEntry in self.aoInfoEntries:
                    if oInfoEntry.sAccessExpr is None or oInfoEntry.sAccessExpr != sAccessExpr:
                        if oInfoEntry.fValue is None or oInfoEntry.fValue != 0:
                            return False;
                return True;
            return False;


    ## PSTATE field info.
    #   0. number of bits
    #   1. AArch64 bit position.
    kdPstateFields = {
        'SP':       (1,  0, ), ## @todo ?
        'EL':       (2,  2, ),
        'F':        (1,  6, ),
        'I':        (1,  7, ),
        'A':        (1,  8, ),
        'D':        (1,  9, ),
        'SSBS':     (1, 12, ),
        'ALLINT':   (1, 13, ),
        'PAN':      (1, 22, ),
        'UAO':      (1, 23, ),
        'DIT':      (1, 24, ),
        'TCO':      (1, 25, ),
        'V':        (1, 28, ),
        'C':        (1, 29, ),
        'Z':        (1, 30, ),
        'N':        (1, 31, ),
        'PM':       (1, 32, ),
        'EXLOCK':   (1, 34, ), # FEAT_GCS
    };

    def transformCodePass2_Concat(self, oNode):  # (ArmAstConcat) -> ArmAstBase
        """ Pass 2: Generic ArmAstConcat. """
        # Process the values and create a parallel list of VBoxAstCppConcatEntry objects.
        aoInfoEntries = []
        for oValue in oNode.aoValues:
            if isinstance(oValue, ArmAstFunction):
                if oValue.isMatchingFunctionCall('Zeros', int) and oValue.aoArgs[0].iValue > 0 and oValue.aoArgs[0].iValue <= 64:
                    aoInfoEntries.append(self.VBoxAstCppConcatEntry(oValue, oValue.aoArgs[0].iValue, fValue = 0));
                else:
                    raise Exception('Unexpected function in Concat() argument list: %s (%s)' % (oValue, oNode,));
            elif isinstance(oValue, (ArmAstValue, ArmAstInteger)):
                (fValue, _, fWildcard, cBitsWidth) = oValue.getValueDetails();
                if fWildcard != 0:
                    raise Exception('Unexpected wildcard value in Concat() argument list: %s (%s)' % (oValue, oNode,));
                aoInfoEntries.append(self.VBoxAstCppConcatEntry(oValue, cBitsWidth, fValue = fValue));
            elif isinstance(oValue, ArmAstField):
                (_, oField, oAccessExprOrInt) = self.lookupRegisterField(oValue.sState, oValue.sName, oValue.sField,
                                                                         'Concat/%s' % (oNode,));
                if isinstance(oAccessExprOrInt, int):
                    aoInfoEntries.append(self.VBoxAstCppConcatEntry(oValue, oField.aoRanges[0].cBitsWidth,
                                                                    fValue = oAccessExprOrInt, oField = oField));
                else:
                    aoInfoEntries.append(self.VBoxAstCppConcatEntry(oValue, oField.aoRanges[0].cBitsWidth,
                                                                    sAccessExpr = oAccessExprOrInt, oField = oField));
            elif isinstance(oValue, ArmAstDotAtom):
                if len(oValue.aoValues) == 2 and oValue.aoValues[0].isMatchingIdentifier('PSTATE'):
                    sField = oValue.aoValues[1].getIdentifierName();
                    tInfo  = self.kdPstateFields.get(sField);
                    if not tInfo:
                        raise Exception('Unexpected PSTAT field in Concat() argument list: %s (%s)' % (oValue, oNode,));
                    oField = spec.ArmFieldsBase(None, [spec.ArmRange(tInfo[1], tInfo[0])], sField); ## @todo aarch32
                    aoInfoEntries.append(self.VBoxAstCppConcatEntry(oValue, tInfo[0], sAccessExpr = 'pVCpu->cpum.GstCtx.fPState',
                                                                    oField = oField));
                else:
                    raise Exception('Unexpected DotAtom in Concat() argument list: %s (%s)' % (oValue, oNode,));
            elif isinstance(oValue, self.VBoxAstCppConcat):
                for oInfoEntry in oValue.aoInfoEntries:
                    aoInfoEntries.append(oInfoEntry.clone())
            else:
                raise Exception('Unexpected value in Concat() argument list: %s: %s (%s)' % (type(oValue), oValue, oNode,));

        # Assign bit positions.  This is done in reverse order as the Concat
        # arguments are in most to least significant bit order.
        iBit = 0;
        cNonValues = 0;
        for oInfoEntry in reversed(aoInfoEntries):
            oInfoEntry.iFirstBit = iBit;
            iBit += oInfoEntry.cBitsWidth;
            cNonValues += 1 if oInfoEntry.fValue is None else 0;

        # If all the entries have fixed values, we can convert this to a C++
        # constant of the appropriate size.
        if cNonValues == 0:
            sExpr  = 'UINT%u_C(' % (iBit,);
            fValue = 0;
            for oInfoEntry in aoInfoEntries:
                fValue |= oInfoEntry.fValue << oInfoEntry.iFirstBit;
            sExpr += '%#x)' % (fValue, );
            return ArmAstCppExpr(sExpr, cBitsWidth = iBit);

        return self.VBoxAstCppConcat(aoInfoEntries, oNode);

    def transformCodePass2_BinaryOp_ConcatAndValueOrInt(self, oNode): # pylint: disable=invalid-name
        """ Pass 2: (AArch64.MDCR_EL2.TDE):(AArch64.MDCR_EL2.TDA) != '00' and similar """
        # First process the value.
        (fValue, _, fWildcard, _) = oNode.oRight.getValueDetails();
        #(fValue, fFixed, fWildcard, cBitsWidth) = oNode.oRight.getValueDetails();

        #
        # Drop the comparison and shifting if we're checking that any of the
        # fields are non-zero.
        #
        if fValue == 0 and fWildcard == 0 and oNode.sOp == '!=':
            if oNode.oLeft.areAllFromSameRegister():
                fMask       = 0;
                sAccessExpr = None;
                asNames     = [];
                for oInfoEntry in oNode.oLeft.aoInfoEntries:
                    if oInfoEntry.fValue is None:
                        fMask |= ((1 << oInfoEntry.oField.aoRanges[0].cBitsWidth) - 1) << oInfoEntry.oField.aoRanges[0].iFirstBit;
                        sAccessExpr = oInfoEntry.sAccessExpr;
                        assert oInfoEntry.oField.sName;
                        asNames.append(oInfoEntry.oField.sName);
                    else:
                        assert oInfoEntry.fValue == 0;
                oNode.oLeft.asExprs = ['%s & UINT64_C(%#x) /*%s*/' % (sAccessExpr, fMask, ','.join(asNames))];
                oNode.oLeft.sExpr = '(%s)' % (oNode.oLeft.asExprs[0],)
                return oNode.oLeft;

        return oNode;

    def transformCodePass2_BinaryOp_DotAtomAndValueOrInt(self, oNode): # pylint: disable=invalid-name
        """ Pass 2: PSTATE.SP == '0' and suchlike. """
        if len(oNode.oLeft.aoValues) == 2:
            (fValue, _, fWildcard, cBitsWidth) = oNode.oRight.getValueDetails();

            sField = oNode.oLeft.aoValues[1].getIdentifierName();
            if isinstance(sField, str) and sField:
                if oNode.oLeft.aoValues[0].isMatchingIdentifier('PSTATE'):
                    tInfo = self.kdPstateFields.get(sField);
                    if not tInfo:
                        raise Exception('Unexpected PSTATE field in binary op: %s (%s)' % (oNode.oLeft, oNode,));
                    if tInfo[0] != cBitsWidth:
                        raise Exception('Mismatching PSTATE field width and value: %s vs %s (%s)'
                                        % (oNode.oLeft, oNode.oRight, oNode,));

                    sExpr = '(pVCpu->cpum.GstCtx.fPState & UINT64_C(%#x)/*%s*/)' % (((1 << tInfo[0]) - 1) << tInfo[1], sField,);
                    if tInfo[0] == 1:
                        if fWildcard:
                            raise Exception('Wildcard value for single bit PSTATE field: %s (%s)' % (oNode.oLeft, oNode,));
                        if (oNode.sOp == '==' and fValue == 1) or (oNode.sOp == '!=' and fValue == 0):
                            return ArmAstCppExpr(sExpr, cBitsWidth = 1);
                        if (oNode.sOp == '==' and fValue == 0) or (oNode.sOp == '!=' and fValue == 1):
                            return ArmAstUnaryOp('!', ArmAstCppExpr(sExpr, cBitsWidth = 1));
                    elif fWildcard == 0:
                        raise Exception('Handle wildcard value for PSTATE field: %s (%s)' % (oNode.oLeft, oNode,));
                    if tInfo[1] != 0:
                        sExpr = '(%s >> %u)' % (sExpr, tInfo[1],);
                    oNode.oLeft  = ArmAstCppExpr(sExpr, cBitsWidth = tInfo[1]);
                    oNode.oRight = ArmAstInteger(fValue, cBitsWidth);
                    return oNode;
        raise Exception('Unexpected dot-atom + value binary op: %s' % (oNode,));

    def transformCodePass2_BinaryOp_InSet(self, oNode): # pylint: disable=invalid-name
        """ Pass 2: iemGetEffHcrEl2NVx(pVCpu, pGstFeats) IN ('1x1') and such. """
        oSet = oNode.oRight;
        if isinstance(oSet, ArmAstSet):
            for iValue, oValue in enumerate(oSet.aoValues):
                if not isinstance(oValue, (ArmAstValue, ArmAstInteger)):
                    raise Exception('Set value #%u is not an Values.Value node: %s' % (iValue, oNode.toString(),));
        elif isinstance(oSet, ArmAstValue):
            oSet = ArmAstSet([oNode.oRight,]);
        else:
            raise Exception('Unexpected use of operator "IN": %s' % (oNode.toString(),));

        if len(oSet.aoValues) == 1:
            (fValue, fFixed, fWildcard, cBitsWidth) = oSet.aoValues[0].getValueDetails();
            if fFixed == 0:
                raise Exception('Bogus wildcard set expression: %s' % (oNode.toString(),));

            if fWildcard != 0:
                oNode.oLeft = ArmAstBinaryOp(oNode.oLeft, 'AND', ArmAstInteger(fFixed, cBitsWidth))
            oNode.sOp = '==';
            oNode.oRight = ArmAstInteger(fValue, cBitsWidth);
            return oNode

        assert False, str(oNode);
        return oNode;


    class VBoxAstCppField(ArmAstCppExpr):
        """ For converted ArmAstField so we optimize them later when processing
        an ArmAstBinaryOp or ArmAstUnaryOp parent node. """
        def __init__(self, sExpr, cBitsWidth, sNoShiftExpr = None, cBitsWidthNoShift = None):
            ArmAstCppExpr.__init__(self, sExpr, cBitsWidth);
            self.sNoShiftExpr      = sNoShiftExpr;
            self.cBitsWidthNoShift = cBitsWidthNoShift;

        def dropShift(self):
            if self.sNoShiftExpr:
                self.sExpr      = self.sNoShiftExpr;
                self.cBitsWidth = self.cBitsWidthNoShift;
            return self;

        def dropExtraParenthesis(self):
            if self.sExpr[0] == '(' and self.sExpr[-1] == ')':
                self.sExpr = self.sExpr[1:-1];
            return self;

    def transformCodePass2_Field(self, oNode): # (ArmAstField) -> ArmAstBase
        """ Pass2: Deal with field accesses (except for AST.Concat). """
        # Most fields can be mapped directly to a CPUMCTX field.
        (_, oField, oAccessExprOrInt) = self.lookupRegisterField(oNode.sState, oNode.sName, oNode.sField, 'Generic field',
                                                                 fWarnOnly = True);
        if not oField:
            return oNode;
        assert len(oField.aoRanges) == 1;

        cBitsWidth = oField.aoRanges[0].cBitsWidth;
        iFirstBit  = oField.aoRanges[0].iFirstBit;

        if isinstance(oAccessExprOrInt, int):
            iValue  = oAccessExprOrInt >> iFirstBit;
            iValue &= (1 << cBitsWidth) - 1;
            return ArmAstInteger(iValue, cBitsWidth); ## @todo annotate

        if cBitsWidth == 1:
            sExpr = '(%s & RT_BIT_%u(%d)/*%s*/)' \
                  % (oAccessExprOrInt, 64 if cBitsWidth >= 32 else 32, iFirstBit, oField.sName);
        else:
            sExpr = '(%s & UINT%u_C(%#x)/*%s*/)' \
                  % (oAccessExprOrInt, 64 if cBitsWidth >= 32 else 32, ((1 << cBitsWidth) - 1) << iFirstBit, oField.sName);
        if iFirstBit == 0:
            return self.VBoxAstCppField(sExpr, cBitsWidth);
        return self.VBoxAstCppField('((%s) >> %u)' % (sExpr, iFirstBit,), cBitsWidth, sExpr, cBitsWidth + iFirstBit);

    def transformCodePass2_Identifier(self, oNode, oInfo): # type: (ArmAstIdentifier, SysRegAccessorInfo) -> ArmAstBase
        """ Pass 2: Deal with register identifiers during assignments. """
        _ = oInfo;
        sState = 'AArch64' if self.isA64Instruction() else 'AArch32';
        oReg   = spec.g_ddoAllArmRegistersByStateByName[sState].get(oNode.sName); # ArmRegister
        if not oReg:
            raise Exception('Assignment/Identifier: Register "%s" not found' % (oNode.sName, ));

        tCpumCtxInfo = g_dRegToCpumCtx.get('%s.%s' % (sState, oNode.sName));
        if not tCpumCtxInfo:
            oXcpt = Exception('Assignment/Identifier: No CPUMCTX mapping for register %s.%s' % (sState, oNode.sName,));
            print('warning: %s' % (oXcpt));
            return oNode;
            #raise oXcpt;

        if isinstance(tCpumCtxInfo[0], int):
            return ArmAstInteger(tCpumCtxInfo[0], 64);
        return ArmAstCppExpr('pVCpu->cpum.GstCtx.%s' % (tCpumCtxInfo[0],), cBitsWidth = 64);

    def transformCodePass2_ParseNVMem(self, oNode):
        if len(oNode.aoValues) in (1, 2):
            off = oNode.aoValues[0].getIntegerOrValue();
            if off is not None and 0 <= off < 4096:
                cBits = 64 if len(oNode.aoValues) == 1 else oNode.aoValues[1].getIntegerOrValue();
                if cBits is not None and cBits in (64, 128):
                    return (off, cBits);
        raise Exception('Bogus NVMem access: %s' % (oNode,));

    #def transformCodePass2_NVMemRead(self, oNode):
    #    """ Pass 2: Translate NVMem[off[,bits]] to function call. """
    #    (off, cBits) = self.transformCodePass2_ParseNVMem(oNode);
    #    return ArmAstCppExpr('iemNVMemReadU%u(%#x)' % (cBits, off,), cBitsWidth = cBits);

    def transformCodePass2_AssignFromNVMem(self, oNode):
        """ Pass 2: Translate NVMem[off[,bits]] to function call. """
        (off, cBits) = self.transformCodePass2_ParseNVMem(oNode.oValue);

        # Assume the variable receiving the assignment is *puDst or similar:
        sValuePtr = oNode.oVar.toString();
        if sValuePtr[0] != '*':
            return oNode;
        sValuePtr = sValuePtr[1:];

        return ArmAstReturn(ArmAstCppExpr('iemNVMemReadU%u(pVCpu, %#x, %s)' % (cBits, off, sValuePtr,), cBitsWidth = 32));

    def transformCodePass2_AssignToNVMem(self, oNode):
        """ Pass 2: Translate NVMem[off[,bits]] to function call. """
        (off, cBits) = self.transformCodePass2_ParseNVMem(oNode.oVar);
        sCall  = 'iemNVMemWriteU%u(pVCpu, %#x, ' % (cBits, off,);
        sValue = oNode.oValue.toStringEx(sLang = 'C');
        if '\n' in sValue:
            sValue = sValue.replace('\n', '\n' + ' ' * (len(sCall) + len('return ')));
        return ArmAstReturn(ArmAstCppExpr(sCall + sValue + ')', cBitsWidth = 32));

    def transformCodePass2_AssignFromUnresolvedReg(self, oNode, oInfo): # pylint: disable=invalid-name
        """ Pass 2: Assignment with a unresolved register on the right side. """
        # Assume the variable receiving the assignment is *puDst or similar:
        sValuePtr = oNode.oVar.toString();
        if sValuePtr[0] != '*':
            return oNode;
        sValuePtr = sValuePtr[1:];

        # The register should match the info one because we need it's ID.
        # Otherwise, we need to look it up and such...
        sRegName = oNode.oValue.getIdentifierName();
        if sRegName and oInfo.oAccessor.oEncoding.sAsmValue == sRegName:
            sRegConst = oInfo.sEnc
        else:
            sRegConst = None;
            if sRegName:
                oReg = spec.g_ddoAllArmRegistersByStateByName[self.getRegStateName()].get(sRegName); # ArmRegister
                if oReg:
                    for oAccessor in oReg.aoAccessors: # ArmAccessorBase
                        if isinstance(oAccessor, spec.ArmAccessorSystem):
                            if oAccessor.oEncoding.sAsmValue == oNode.oValue.sName:
                                try:
                                    sRegConst = oAccessor.oEncoding.getSysRegIdCreate();
                                except Exception:
                                    pass;
                                else:
                                    break;
            if not sRegConst:
                return oNode;

        oInfo.cAssignmentsWithUnresolvedRegs += 1;
        return ArmAstReturn(ArmAstCppExpr('%s_novar(pVCpu, %s, "%s", %s)' % (self.sFuncPrefix, sRegConst, sRegName, sValuePtr,),
                                          cBitsWidth = 32));

    def transformCodePass2_AssignToUnresolvedReg(self, oNode, oInfo): # pylint: disable=invalid-name
        """ Pass 2: Assignment to an unresolved register on the left side. """
        # The register should match the info one because we need it's ID.
        if not oNode.oVar.isMatchingIdentifier(oInfo.oAccessor.oEncoding.sAsmValue):
            return oNode;

        oInfo.cAssignmentsWithUnresolvedRegs += 1;
        return ArmAstReturn(ArmAstCppExpr('%s_novar(pVCpu, %s, "%s", %s)'
                                          % (self.sFuncPrefix, oInfo.sEnc, oInfo.oAccessor.oEncoding.sAsmValue,
                                             oNode.oValue.toStringEx(sLang = 'C').replace('\n', '\n        '),), # ugly.
                                          cBitsWidth = 32));


    def transformCodePass2Callback(self, oNode, fEliminationAllowed, oInfo, aoStack):
        """ Callback for pass 2: C++ translation. """
        if isinstance(oNode, ArmAstFunction):
            # Undefined() -> return iemRaiseUndefined(pVCpu);
            if oNode.isMatchingFunctionCall('Undefined'):
                return ArmAstReturn(ArmAstCppExpr('iemRaiseUndefined(pVCpu)', cBitsWidth = 32));

            # IsFeatureImplemented(FEAT_xxxx) -> pGstFeat->fXxxx:
            if oNode.sName == 'IsFeatureImplemented':
                return self.transformCodePass2_IsFeatureImplemented(oNode, oInfo);

            # EffectiveHCR_EL2_NVx
            if oNode.sName == 'EffectiveHCR_EL2_NVx':
                return self.transformCodePass2_EffectiveHCR_EL2_NVx(oNode, oInfo);

        elif isinstance(oNode, ArmAstBinaryOp):
            # PSTATE.EL == EL0 and similar:
            if oNode.oLeft.isMatchingDotAtom('PSTATE', 'EL'):
                idxEl = self.kdELxToNum.get(oNode.oRight.getIdentifierName(), -1);
                if idxEl >= 0:
                    oNode.oLeft  = ArmAstCppExpr('IEM_F_MODE_ARM_GET_EL(pVCpu->iem.s.fExec)', cBitsWidth = 2);
                    oNode.oRight = ArmAstInteger(idxEl, cBitsWidth = 2);
                return oNode;

            ## (AArch64.MDCR_EL2.TDE):(AArch64.MDCR_EL2.TDA) != '00' and similar:
            if (    isinstance(oNode.oLeft, self.VBoxAstCppConcat)
                and isinstance(oNode.oRight, (ArmAstValue, ArmAstInteger))
                and ArmAstBinaryOp.kdOps[oNode.sOp] in (ArmAstBinaryOp.ksOpTypeLogical, ArmAstBinaryOp.ksOpTypeCompare) ):
                return self.transformCodePass2_BinaryOp_ConcatAndValueOrInt(oNode);

            # PSTATE.SP == '0' and similar:
            if isinstance(oNode.oLeft, ArmAstDotAtom) and isinstance(oNode.oRight, (ArmAstValue, ArmAstInteger)):
                return self.transformCodePass2_BinaryOp_DotAtomAndValueOrInt(oNode);

            ## iemGetEffHcrEl2NVx(pVCpu, pGstFeats) IN ('1x1') and such fun stuff.
            if oNode.sOp == 'IN':
                return self.transformCodePass2_BinaryOp_InSet(oNode);

            # Drop unnecessary field shifting when and compares for non-zero field checks.
            if isinstance(oNode.oLeft, self.VBoxAstCppField):
                if (   (oNode.sOp == '==' and oNode.oRight.isMatchingIntegerOrValue(1) and oNode.oLeft.cBitsWidth == 1)
                    or (oNode.sOp == '!=' and oNode.oRight.isMatchingIntegerOrValue(0))):
                    return oNode.oLeft.dropShift();
                if (oNode.sOp == '==' and oNode.oRight.isMatchingIntegerOrValue(0)):
                    return ArmAstUnaryOp('!', oNode.oLeft.dropShift());
                if ArmAstBinaryOp.kdOps[oNode.sOp] == ArmAstBinaryOp.ksOpTypeLogical:
                    oNode.oLeft = oNode.oLeft.dropShift();
            elif isinstance(oNode.oRight, self.VBoxAstCppField):
                if ArmAstBinaryOp.kdOps[oNode.sOp] == ArmAstBinaryOp.ksOpTypeLogical:
                    oNode.oRight = oNode.oRight.dropShift();

        elif isinstance(oNode, ArmAstConcat):
            return self.transformCodePass2_Concat(oNode);

        elif (    isinstance(oNode, ArmAstField)
              and (   not aoStack
                   or not isinstance(aoStack[-1], ArmAstConcat))):
            return self.transformCodePass2_Field(oNode);

        elif (    isinstance(oNode, ArmAstIdentifier)
              and aoStack
              and isinstance(aoStack[-1], ArmAstAssignment)):
            return self.transformCodePass2_Identifier(oNode, oInfo);

        elif isinstance(oNode, ArmAstIfList):
            # Drop double parentheses around field extraction expressions when they are the sole if condition.
            for idxIfCond, oIfCond in enumerate(oNode.aoIfConditions):
                if isinstance(oIfCond, self.VBoxAstCppField):
                    oNode.aoIfConditions[idxIfCond] = oIfCond.dropExtraParenthesis();

        elif isinstance(oNode, ArmAstSquareOp):
            ## Translate NVMem[xxx[,128]] to function calls depending on context.
            #if (    oNode.oVar.isMatchingIdentifier('NVMem')
            #    and (not aoStack or not isinstance(aoStack[-1], ArmAstAssignment) or aoStack[-1].oVar is not oNode)):
            #    return self.transformCodePass2_NVMemRead(oNode);
            pass;

        elif isinstance(oNode, ArmAstAssignment):
            if isinstance(oNode.oVar, ArmAstSquareOp):
                if oNode.oVar.oVar.isMatchingIdentifier('NVMem'):
                    return self.transformCodePass2_AssignToNVMem(oNode);
            elif isinstance(oNode.oValue, ArmAstSquareOp) and oNode.oValue.oVar.isMatchingIdentifier('NVMem'):
                return self.transformCodePass2_AssignFromNVMem(oNode);
            elif isinstance(oNode.oValue, ArmAstIdentifier):
                return self.transformCodePass2_AssignFromUnresolvedReg(oNode, oInfo);
            elif isinstance(oNode.oVar, ArmAstIdentifier):
                return self.transformCodePass2_AssignToUnresolvedReg(oNode, oInfo);

        _ = fEliminationAllowed;
        return oNode;

    def transformCodePass2(self, oInfo, oCode):
        """ Code transformation pass 2: C++ translation. """
        return oCode.transform(self.transformCodePass2Callback, True, oInfo, []);


class SysRegGeneratorA64Mrs(SysRegGeneratorBase):

    def __init__(self):
        SysRegGeneratorBase.__init__(self, 'A64.MRS', 'iemCImplA64_mrs');

    def generateOneHandler(self, oInfo):
        """ Generates one register access for A64.MRS. """
        asLines = [
            '',
            '/**',
            ' * %s - %s' % (oInfo.oAccessor.oEncoding.sAsmValue, oInfo.oAccessor.oEncoding.dNamedValues,),
            ' * Transformation status: %u - %s'
            % (oInfo.cIncompleteNodes, 'complete' if oInfo.cIncompleteNodes == 0 else 'incomplete'),
            ' */',
            'static VBOXSTRICTRC iemCImplA64_mrs_%s(PVMCPU pVCpu, uint64_t *puDst%s)'
            % (oInfo.oAccessor.oEncoding.sAsmValue, ', uint32_t uInstrEssence' if oInfo.cInstrEssenceRefs > 0 else ''),
            '{',
        ];
        if oInfo.cIncompleteNodes > 0 or not oInfo.oCode:
            asLines += [
                '    RT_NOREF(pVCpu, puDst%s);' % (', uInstrEssence' if oInfo.cInstrEssenceRefs > 0 else ''),
                '#ifdef IEM_SYSREG_TODO',
            ];
        elif isinstance(oInfo.oCode, ArmAstReturn):

            asLines.append('    RT_NOREF(puDst);');
        if oInfo.cCallsToIsFeatureImplemented > 0:
            asLines.append('    const CPUMFEATURESARMV8 * const pGstFeats = IEM_GET_GUEST_CPU_FEATURES(pVCpu);');
        if oInfo.oCode:
            asLines.extend(oInfo.oCode.toStringList('    ', 'C'));

        if oInfo.cIncompleteNodes > 0 or not oInfo.oCode:
            asLines += [
                '#endif',
                '    return VERR_IEM_ASPECT_NOT_IMPLEMENTED;'
            ];
        elif not isinstance(oInfo.oCode, ArmAstReturn):
            asLines.append('    return VINF_SUCCESS;');

        asLines.append('    /* -------- Original code specification: -------- */');
        asLines.extend([ '    // ' + sLine for sLine in oInfo.oAccessor.oAccess.toStringList()]);

        asLines += [
            '}',
        ];
        return asLines;

    def generateMainFunction(self):
        """ Generates the CIMPL function for A64.MRS. """
        asLines = [
            '',
            '/**',
            ' * Implements the MRS instruction.',
            ' *',
            ' * @returns Strict VBox status code.',
            ' * @param   pVCpu       The cross context virtual CPU structure of the',
            ' *                      calling thread.',
            ' * @param   idSysReg    The system register to read from (IPRT format).',
            ' * @param   idGprDst    The destination GPR register number (for exceptions).',
            ' * @param   puDst       Where to return the value.',
            ' */',
            'DECLHIDDEN(VBOXSTRICT) iemCImplA64_mrs_generic(PVMCPU pVCpu, uint32_t idSysReg, uint32_t idGprDst,',
            '                                               uint64_t *puDst)',
            '{',
            '    uint32_t const   uInstrEssence = idSysReg | (idGprDst << 24);',
            '    uint64_t         uZeroDummy;',
            '    uint64_t * const puDst = idGprDst < ARMV8_A64_REG_XZR',
            '                           ? &pVCpu->cpum.GstCtx.aGRegs[idGprDst].x : &uZeroDummy;',
            '    switch (idSysReg)',
            '    {',
        ];
        for oInfo in self.aoInfo:
            if oInfo.sEnc[0] == 'A':
                asLines.append('        case %s: %sreturn iemCImplA64_mrs_%s(pVCpu, puDst%s);'
                               % (oInfo.sEnc, ' ' * (45 - len(oInfo.sEnc)), oInfo.oAccessor.oEncoding.sAsmValue,
                                  ', uInstrEssence' if oInfo.cInstrEssenceRefs else '',));
        asLines += [
            '    }',
            '    /* Fall back on handcoded handler. */',
            '    return iemCImplA64_mrs_fallback(pVCpu, idGprDst, idSysReg);',
            '}',
            '',
            '/**',
            ' * Implements the MRS instruction.',
            ' *',
            ' * @param   idSysReg    The system register to read from (IPRT format).',
            ' * @param   idGprDst    The destination GPR register number.',
            ' */',
            'IEM_CIMPL_DEF_2(iemCImplA64_mrs, uint32_t, idSysReg, uint32_t, idGprDst)',
            '{',
            '    uint64_t         uZeroDummy;',
            '    uint64_t * const puDst = idGprDst < ARMV8_A64_REG_XZR',
            '                           ? &pVCpu->cpum.GstCtx.aGRegs[idGprDst].x : &uZeroDummy;',
            '    return iemCImplA64_mrs_generic(pVCpu, idSysReg, idGprDst, puDst);',
            '}',
        ];
        return asLines;


    def transformCodePass2_Identifier(self, oNode, oInfo): # type: (ArmAstIdentifier, SysRegAccessorInfo) -> ArmAstBase
        # Iff this is anything in the ID block, replace it with a lookup call.
        if self.isIdRegisterEncoding(oInfo.oAccessor.oEncoding):
            return ArmAstCppExpr('CPUMCpuIdLookupSysReg(pVCpu, %s)' % (oInfo.sEnc), cBitsWidth = 64);
        return super().transformCodePass2_Identifier(oNode, oInfo);

    def transformCodePass2Callback(self, oNode, fEliminationAllowed, oInfo, aoStack):
        """ Callback used by the second pass."""
        if oNode.isMatchingSquareOp('X', 't', 64):
            return ArmAstCppExpr('*puDst', cBitsWidth = 64);

        return super().transformCodePass2Callback(oNode, fEliminationAllowed, oInfo, aoStack);


#
# Generators
#

class IEMArmGenerator(object):

    def __init__(self):
        self.oOptions        = None;
        self.dDecoderRoots   = {};
        self.dRootsIndexExpr = {};


    def constructDecoder(self):
        """
        Creates the decoder(s) to the best our abilities.
        """
        for oSet in spec.g_aoArmInstructionSets:
            oRoot = DecoderNode(sorted(oSet.aoAllInstructions,
                                       key = operator.attrgetter('fFixedMask','fFixedValue', 'sName')),#[:384],
                                0, 0);
            self.dDecoderRoots[oSet.sName] = oRoot;
            oRoot.constructNextLevel(0, sys.maxsize);

            # Set the fDecoderLeafCheckNeeded property of the instructions.
            oRoot.setInstrProps(0);


    def generateLicenseHeader(self, oVerInfo):
        """
        Returns the lines for a license header.
        """
        sDashYear = '-%s' % datetime.date.today().year;
        if sDashYear == '-2025':
            sDashYear = '';
        return [
            '/*',
            ' * Autogenerated by $Id$',
            ' * from the open source %s specs, build %s (%s)'
            % (oVerInfo['architecture'], oVerInfo['build'], oVerInfo['ref'],),
            ' * dated %s.' % (oVerInfo['timestamp'],),
            ' *',
            ' * Do not edit!',
            ' */',
            '',
            '/*',
            ' * Copyright (C) 2025' + sDashYear + ' Oracle and/or its affiliates.',
            ' *',
            ' * This file is part of VirtualBox base platform packages, as',
            ' * available from https://www.virtualbox.org.',
            ' *',
            ' * This program is free software; you can redistribute it and/or',
            ' * modify it under the terms of the GNU General Public License',
            ' * as published by the Free Software Foundation, in version 3 of the',
            ' * License.',
            ' *',
            ' * This program is distributed in the hope that it will be useful, but',
            ' * WITHOUT ANY WARRANTY; without even the implied warranty of',
            ' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU',
            ' * General Public License for more details.',
            ' *',
            ' * You should have received a copy of the GNU General Public License',
            ' * along with this program; if not, see <https://www.gnu.org/licenses>.',
            ' *',
            ' * SPDX-License-Identifier: GPL-3.0-only',
            ' */',
            '',
            '',
        ];

    def generateImplementationStubHdr(self, sInstrSet):
        """
        Generate implementation stubs.
        """
        asLines = self.generateLicenseHeader(spec.g_oArmInstructionVerInfo);

        # Organize this by instruction set, groups and instructions.
        sPrevCategory = '';
        for oInstr in sorted(spec.g_dArmInstructionSets[sInstrSet].aoAllInstructions,
                             key = spec.ArmInstruction.getSetAndGroupNames):
            # New group/category?
            sCategory = ' / '.join(oInstr.getSetAndGroupNames(),);
            if sCategory != sPrevCategory:
                asLines += [
                    '',
                    '',
                    '/*',
                    ' *',
                    ' * Instruction Set & Groups: %s' % (sCategory,),
                    ' *',
                    ' */',
                ];
                sPrevCategory = sCategory;

            # Emit the instruction stub.
            asArgs  = [ oField.sName for oField in oInstr.getNamedNonFixedFieldsSortedByPosition() ];
            asLines += [
                '',
                '/* %s (%08x/%08x) */' % (oInstr.sAsmDisplay, oInstr.fFixedMask, oInstr.fFixedValue,),
                '//#define IEM_INSTR_IMPL_%s__%s(%s)' % (sInstrSet, oInstr.getCName(), ', '.join(asArgs)),
                '',
            ]

        return (True, asLines);

    def generateA64ImplementationStubHdr(self, sFilename, iPartNo):
        _ = sFilename; _ = iPartNo;
        return self.generateImplementationStubHdr('A64');


    #
    # Decoder.
    #

    def generateDecoderFunctions(self, sInstrSet):
        """
        Generates the leaf decoder functions.
        """

        class CExprHelper(object):
            def __init__(self, oInstr):
                self.oInstr = oInstr;

            def getFieldInfo(self, sName, sVar = '', sNamespace = ''):
                if not sVar and not sNamespace:
                    oInstr = self.oInstr;
                    oField = oInstr.getFieldByName(sName, False);
                    if oField:
                        return (sName, oField.cBitsWidth);
                    # Look for the field in groups and sets and generate a name that extracts it from uOpcode:
                    for oParent in oInstr.oParent.getUpIterator():
                        oField = oParent.getFieldByName(sName, False);
                        if oField:
                            fFieldOpMask = oField.getShiftedMask();
                            if (oInstr.fFixedMask & fFieldOpMask) == fFieldOpMask:
                                return ('%#x /*%s@%u*/'
                                        % ((oInstr.fFixedValue & fFieldOpMask) >> oField.iFirstBit, sName, oField.iFirstBit),
                                        oField.cBitsWidth);
                            return ('((uOpcode >> %u) & %#x)' % (oField.iFirstBit, oField.getMask()), oField.cBitsWidth);
                raise Exception('Field (%s.%s.)%s was not found for instruction %s'
                                % (sNamespace, sVar, sName, oInstr.sName,));

            def convertFunctionCall(self, oCall):
                if oCall.sName == 'IsFeatureImplemented':
                    if len(oCall.aoArgs) != 1:
                        raise Exception('Unexpected argument count for IsFeatureImplemented call: %s' % (oCall.aoArgs,));
                    if not isinstance(oCall.aoArgs[0], ArmAstIdentifier):
                        raise Exception('Argument to IsFeatureImplemented is not an identifier: %s (%s)'
                                        % (oCall.aoArgs[0].sType, oCall.aoArgs[0]));
                    sFeatureNm = oCall.aoArgs[0].sName;
                    sCpumFeature = g_dSpecFeatToCpumFeat.get(sFeatureNm, None);
                    if sCpumFeature is None:
                        raise Exception('Unknown IsFeatureImplemented parameter: %s (see g_dSpecFeatToCpumFeat)' % (sFeatureNm));
                    if isinstance(sCpumFeature, str):
                        return 'IEM_GET_GUEST_CPU_FEATURES(pVCpu)->%s /*%s*/' % (sCpumFeature, sFeatureNm,)
                    if sCpumFeature is True:  return 'true /*%s*/' % (sFeatureNm,);
                    if sCpumFeature is False: return 'false /*%s*/' % (sFeatureNm,);
                    return 'false /** @todo IEM_GET_GUEST_CPU_FEATURES(pVCpu)->%s */' % (sFeatureNm,);
                raise Exception('Call to unsupported function: %s (%s)' % (oCall.sName, oCall.aoArgs,));

        asLines = [];
        for oInstr in sorted(spec.g_dArmInstructionSets[sInstrSet].aoAllInstructions,
                             key = operator.attrgetter('sName', 'sAsmDisplay')):
            sCName = oInstr.getCName();
            asLines += [
                '',
                '/* %08x/%08x: %s' % (oInstr.fFixedMask, oInstr.fFixedValue, oInstr.sAsmDisplay,),
                '   %s */'% (oInstr.getSetAndGroupNamesWithLabels(),),
                'FNIEMOP_DEF_1(iemDecode%s_%s, uint32_t, uOpcode)' % (sInstrSet, sCName,),
                '{',
            ];

            # The final decoding step, if needed.
            sIndent = '';
            asTail  = [];
            if oInstr.fDecoderLeafCheckNeeded:
                asLines += [
                    '    if ((uOpcode & UINT32_C(%#010x)) == UINT32_C(%#010x))' % (oInstr.fFixedMask, oInstr.fFixedValue,),
                    '    {',
                ];
                asTail  = [
                    '    Log(("Invalid instruction %%#x at %%x\\n", uOpcode, pVCpu->cpum.GstCtx.Pc.u64));',
                    '    IEMOP_RAISE_INVALID_OPCODE_RET();',
                    '}',
                ];
                sIndent = '    ';


            # Decode the fields and prepare for passing them as arguments.
            asArgs  = [];
            sLogFmt = '';
            for oField in oInstr.getNamedNonFixedFieldsSortedByPosition(): # ArmEncodesetField
                assert oField.sName and oField.fFixed != oField.getMask();
                asArgs.append(oField.sName);
                if oField.cBitsWidth < 4:
                    sLogFmt += ' %s=%%u' % (oField.sName,)
                else:
                    sLogFmt += ' %s=%%#x' % (oField.sName,)
                asLines.append('%s    uint32_t const %-10s = (uOpcode >> %2u) & %#010x;'
                               % (sIndent, oField.sName, oField.iFirstBit, (1 << oField.cBitsWidth) - 1,));

            # Any additional conditions for the instructions.
            if not oInstr.oCondition.isBoolAndTrue():
                asLines += [
                    sIndent + '    if (' + oInstr.oCondition.toCExpr(CExprHelper(oInstr)) + ')',
                    sIndent + '    {',
                ];

                asTail = [
                    sIndent + '    Log(("Invalid instruction %%#x at %%x (cond)\\n", uOpcode, pVCpu->cpum.GstCtx.Pc.u64));',
                    sIndent + '    IEMOP_RAISE_INVALID_OPCODE_RET();',
                    sIndent + '}',
                ] + asTail;
                sIndent += '    ';

            # Log and call implementation.
            asLines += [
                '%s    LogFlow(("%%018x/%%010x: %s%s\\n", %s));'
                % (sIndent, sCName, sLogFmt, ', '.join(['pVCpu->cpum.GstCtx.Pc.u64', 'uOpcode',] + asArgs),),
                '#ifdef IEM_INSTR_IMPL_%s__%s' % (sInstrSet, sCName,),
                '%s    IEM_INSTR_IMPL_%s__%s(%s);' % (sIndent, sInstrSet, sCName, ', '.join(asArgs),),
                '#else',
                '%s    RT_NOREF(%s);' % (sIndent, ', '.join(asArgs + ['pVCpu', 'uOpcode',]),),
                '%s    return VERR_IEM_INSTR_NOT_IMPLEMENTED;' % (sIndent,),
                '#endif',
                '%s}' % (sIndent),
            ];

            asLines.extend(asTail);
        return asLines;


    class DecoderCodeBlock(object):
        """ A code block. """

        def __init__(self, sInstrSet, sName, sMatches, sStats = None):
            self.sHash     = sInstrSet;
            self.sName     = sName;
            self.asMatches = [sMatches,];
            self.sStats    = sStats;

        def getName(self):
            return self.sName;

        def getLines(self):
            return [
                '',
                '/* %s */' % ('\n   '.join(self.asMatches if not self.sStats else list(self.asMatches) + [self.sStats,]),),
            ];

        def getHash(self):
            return self.sHash;

        def _addLinesToHash(self, asLines):
            """ Adds the lines to the hash value. """
            oHash = hashlib.sha256();
            oHash.update(b'%u lines\n' % (len(asLines),));
            for sLine in asLines:
                oHash.update(sLine.encode('utf-8'));
            self.sHash += '-' + oHash.hexdigest();

    class DecoderCodeMultiIfFunc(DecoderCodeBlock):
        """ Helper class for deduplicating multiple-if functions. """
        def __init__(self, sInstrSet, oNode, uDepth):
            IEMArmGenerator.DecoderCodeBlock.__init__(self, sInstrSet, oNode.getFuncName(sInstrSet, uDepth),
                                                      '%08x/%08x level %u' % (oNode.fCheckedMask, oNode.fCheckedValue, uDepth,) );
            self.asBody = [];
            for oInstr in oNode.aoInstructions:
                self.asBody += [
                    '    if ((uOpcode & UINT32_C(%#010x)) == UINT32_C(%#010x))' % (oInstr.fFixedMask, oInstr.fFixedValue,),
                    '        return iemDecode%s_%s(pVCpu, uOpcode);' % (sInstrSet, oInstr.getCName(),),
                ];
            ## @todo check if the masks are restricted to a few bit differences at
            ## this point and we can skip the iemDecodeA64_Invalid call.
            self.asBody += [
                '    return iemDecode%s_Invalid(pVCpu, uOpcode);' % (sInstrSet,),
            ];
            self._addLinesToHash(self.asBody);

        def getLines(self):
            asLines  = IEMArmGenerator.DecoderCodeBlock.getLines(self);
            asLines += [
                'FNIEMOP_DEF_1(%s, uint32_t, uOpcode)' % (self.getName(),),
                '{',
            ];
            asLines += self.asBody;
            asLines += [
                '}',
            ];
            return asLines;

    class DecoderCodeTableLeafEntry(object):
        """ Special DecoderCodeTableFunc::dChildCode for leaf decoder functions. """
        def __init__(self, sName):
            self.sName = sName;

        def getHash(self):
            return self.sName;

        def getName(self):
            return self.sName;

    class DecoderCodeTableFunc(DecoderCodeBlock):
        """ Helper class for table based decoder function. """

        def __init__(self, sInstrSet, sName, sMatches, sStats, uDepth, cTabEntries, dChildCode, asIdx):
            IEMArmGenerator.DecoderCodeBlock.__init__(self, sInstrSet, sName, sMatches, sStats);
            self.sInstrSet   = sInstrSet;
            self.uDepth      = uDepth;
            self.cTabEntries = cTabEntries;
            self.dChildCode  = dChildCode;      # Note! DecoderCodeBlock or DecoderCodeTableLeafEntry instances.
            self.asIdx       = asIdx;

            self._addLinesToHash(asIdx);
            self._addLinesToHash(['%s-%s' % (idx, oCodeBlock.getHash(),) for idx, oCodeBlock in dChildCode.items()]);

        def getLines(self):
            # Generate the function.  For the top level we just do the table, as
            # the functions are static and we need the interpreter code to be able
            # to address the symbol and this is the speedier way.
            asLines = IEMArmGenerator.DecoderCodeBlock.getLines(self);
            if self.uDepth > 0:
                asLines += [
                    'FNIEMOP_DEF_1(%s, uint32_t, uOpcode)' % (self.getName(),),
                    '{',
                    '    static PFIEMOPU32 const s_apfn[] =',
                    '    {',
                ];
                sTabNm  = 's_apfn';
                sIndent = '    ';
            else:
                sTabNm  = 'g_apfnIemInterpretOnly' + self.sInstrSet;
                asLines += [
                    'PFIEMOPU32 const %s[] =' % (sTabNm,),
                    '{',
                ];
                sIndent = '';

            idxPrev = -1;
            for idx in sorted(self.dChildCode):
                idxPrev += 1;
                while idxPrev < idx:
                    asLines.append(sIndent + '    iemDecode%s_Invalid, // %s' % (self.sInstrSet, idxPrev,));
                    idxPrev += 1;
                asLines.append('%s    %s,' % (sIndent, self.dChildCode[idx].getName(),));

            while idxPrev + 1 < self.cTabEntries:
                idxPrev += 1;
                asLines.append(sIndent + '    iemDecode%s_Invalid, // %s' % (self.sInstrSet, idxPrev,));

            asLines += [
                '%s};' % (sIndent,),
                '%sAssertCompile(RT_ELEMENTS(%s) == %#x);' % (sIndent, sTabNm, self.cTabEntries,),
                '',
            ];

            if self.uDepth > 0:
                asLines += self.asIdx;
                asLines += [
                    '    return s_apfn[idx](pVCpu, uOpcode);',
                    '}'
                ];
            return asLines;


    def generateDecoderCode(self, sInstrSet, oNode, uDepth, dCodeCache):
        """
        Recursively generates the decoder code.
        """
        assert oNode.fChildMask != 0 and oNode.fChildMask not in (0x7fffffff, 0xffffffff, 0x4fffffff), \
            'fChildMask=%s #dChildren=%s aoInstr=%s' % (oNode.fChildMask, len(oNode.dChildren), oNode.aoInstructions,);
        assert oNode.dChildren;

        #
        # First recurse.
        #
        aoCodeBlocks    = [];
        dChildCode      = {};
        cLeafEntries    = 0;
        cMultiIfEntries = 0;
        cReusedCode     = 0;
        for idx in sorted(oNode.dChildren):
            oChildNode = oNode.dChildren[idx];
            if oChildNode.dChildren:
                aoSubCodeBlocks = self.generateDecoderCode(sInstrSet, oChildNode, uDepth + 1, dCodeCache);
            elif oChildNode.fChildMask == DecoderNode.kfChildMaskMultipleOpcodeValueIfs:
                assert len(oChildNode.aoInstructions) > 1;
                aoSubCodeBlocks = [IEMArmGenerator.DecoderCodeMultiIfFunc(sInstrSet, oChildNode, uDepth + 1),];
                cMultiIfEntries += 1;
            else:
                assert len(oChildNode.aoInstructions) == 1;
                assert oChildNode.fChildMask in [DecoderNode.kfChildMaskOpcodeValueIf, 0];
                cLeafEntries += 1;
                dChildCode[idx] = IEMArmGenerator.DecoderCodeTableLeafEntry(oChildNode.getFuncName(sInstrSet, -1));
                continue;

            oCodeBlock  = aoSubCodeBlocks[-1];
            oCachedCode = dCodeCache.get(oCodeBlock.getHash(), None);
            if len(aoSubCodeBlocks) != 1 or oCachedCode is None:
                assert oCachedCode is None; # Code shouldn't be in the hash if it has new dependencies!
                dChildCode[idx] = oCodeBlock;
                aoCodeBlocks.extend(aoSubCodeBlocks);
                dCodeCache[oCodeBlock.getHash()] = oCodeBlock; # comment out of disable code reuse.
            else:
                #print('debug: code cache hit');
                oCachedCode.asMatches += oCodeBlock.asMatches;
                dChildCode[idx] = oCachedCode;
                cReusedCode += 1;

        assert len(dChildCode) == len(oNode.dChildren);
        assert dChildCode;

        #
        # Match info w/ stats.
        #
        cTabEntries = 1 << oNode.fChildMask.bit_count();
        sStats   = 'mask=%#x entries=%#x children=%#x valid=%%%u (%#x) leaf=%%%u (%#x) multi-if=%%%u (%#x) reuse=%%%u (%#x)' \
                 % (oNode.fChildMask, cTabEntries, len(oNode.dChildren),
                    int(round(len(oNode.dChildren) * 100.0 / cTabEntries)), len(oNode.dChildren),
                    int(round(cLeafEntries         * 100.0 / cTabEntries)), cLeafEntries,
                    int(round(cMultiIfEntries      * 100.0 / cTabEntries)), cMultiIfEntries,
                    int(round(cReusedCode          * 100.0 / cTabEntries)), cReusedCode, );
        if uDepth == 0:
            sMatches = '--decoder-hint0 %#x' % (oNode.fChildMask,);
        elif uDepth == 1 and len(oNode.aoInstructions) >= self.oOptions.iDecoderL1Threshold:
            sMatches = '--decoder-hint1 %#x/%#x/%#x' % (oNode.fCheckedMask, oNode.fCheckedValue, oNode.fChildMask);
        else:
            sMatches = '%08x/%08x level %u' % (oNode.fCheckedMask, oNode.fCheckedValue, uDepth,);

        #
        # Code for extracting the index from uOpcode.
        #
        aaiAlgo = MaskZipper.compileAlgo(oNode.fChildMask);
        assert aaiAlgo, 'fChildMask=%s #children=%s instrs=%s' % (oNode.fChildMask, len(oNode.dChildren), oNode.aoInstructions,);
        asIdx = [
            '    /* fMask=%#010x -> %#010x */' % (oNode.fChildMask, cTabEntries - 1),
            '    uintptr_t const idx = ((uOpcode >> %2u) & UINT32_C(%#010x)) /* bit %2u L %u -> 0 */'
            % (aaiAlgo[0][0], aaiAlgo[0][2], aaiAlgo[0][0], aaiAlgo[0][2].bit_count(), ),
        ];
        for iSrcBit, iDstBit, fMask in aaiAlgo[1:]:
            asIdx.append('                        | ((uOpcode >> %2u) & UINT32_C(%#010x)) /* bit %2u L %u -> %u */'
                         % (iSrcBit - iDstBit, fMask << iDstBit, iSrcBit, fMask.bit_count(), iDstBit));
        asIdx[-1] += ';';

        # For the top level table, we save the expression so we can later put in a header file.
        if uDepth == 0:
            self.dRootsIndexExpr[sInstrSet] = asIdx;

        #
        # Create the code block for this table-based decoder function.
        #
        oCodeBlock = IEMArmGenerator.DecoderCodeTableFunc(sInstrSet, oNode.getFuncName(sInstrSet, uDepth), sMatches, sStats,
                                                          uDepth, cTabEntries, dChildCode, asIdx)
        return aoCodeBlocks + [oCodeBlock,];

    def generateDecoderCpp(self, sInstrSet):
        """ Generates the decoder data & code. """
        if sInstrSet not in self.dDecoderRoots:
            raise Exception('Instruction set not found: %s' % (sInstrSet,));

        asLines = self.generateLicenseHeader(spec.g_oArmInstructionVerInfo);
        asLines += [
            '#define LOG_GROUP LOG_GROUP_IEM',
            '#define VMCPU_INCL_CPUM_GST_CTX',
            '#include "IEMInternal.h"',
            '#include <VBox/vmm/vm.h>',
            '#include "VBox/err.h"',
            '',
            '#include "iprt/armv8.h"',
            '',
            '#include "IEMMc.h"',
            '#include "IEMInline-armv8.h"',
            '',
            '#include "%s"' % (os.path.basename(self.oOptions.sFileDecoderHdr) if self.oOptions.sFileDecoderHdr
                               else 'IEMAllIntpr%sTables-armv8.h' % (sInstrSet),),
            '#include "%s"' % (os.path.basename(self.oOptions.sFileStubHdr) if self.oOptions.sFileStubHdr
                               else 'IEMAllInstr%sImpl.h' % (sInstrSet),),
            '',
            '',
            '/** Invalid instruction decoder function. */',
            'FNIEMOP_DEF_1(iemDecode%s_Invalid, uint32_t, uOpcode)' % (sInstrSet,),
            '{',
            '    Log(("Invalid instruction %#x at %x\\n", uOpcode, pVCpu->cpum.GstCtx.Pc.u64));',
            '    RT_NOREF_PV(uOpcode);',
            '    IEMOP_RAISE_INVALID_OPCODE_RET();',
            '}',
        ];

        asLines += self.generateDecoderFunctions(sInstrSet);

        dCodeCache   = {};
        assert self.dDecoderRoots[sInstrSet].dChildren;
        aoCodeBlocks = self.generateDecoderCode(sInstrSet, self.dDecoderRoots[sInstrSet], 0, dCodeCache);
        for oCodeBlock in aoCodeBlocks:
            asLines.extend(oCodeBlock.getLines());

        return (True, asLines);

    def generateA64DecoderCpp(self, sFilename, iPartNo):
        _ = sFilename; _ = iPartNo;
        return self.generateDecoderCpp('A64');


    def generateDecoderHdr(self, sFilename, iPartNo):
        """ Generates the decoder header file. """
        _ = iPartNo;

        asLines = self.generateLicenseHeader(spec.g_oArmInstructionVerInfo);
        sBlockerName = re.sub('[.-]', '_', os.path.basename(sFilename));
        asLines += [
            '#ifndef VMM_INCLUDED_SRC_VMMAll_target_armv8_%s' % (sBlockerName,),
            '#define VMM_INCLUDED_SRC_VMMAll_target_armv8_%s' % (sBlockerName,),
            '#ifndef RT_WITHOUT_PRAGMA_ONCE',
            '# pragma once',
            '#endif',
            '',
        ];
        for sInstrSet in sorted(self.dDecoderRoots.keys()):
            asLines += [
                '/** The top-level %s decoder table for the IEM interpreter. */' % (sInstrSet,),
                'extern PFIEMOPU32 const g_apfnIemInterpretOnly%s[%#x];'
                % (sInstrSet, 1 << self.dDecoderRoots[sInstrSet].fChildMask.bit_count()),
                '',
                '/**',
                ' * Calculates the index for @a uOpcode in g_apfnIemInterpretOnly%s.' % (sInstrSet,),
                ' */',
                'DECL_FORCE_INLINE(uintptr_t) iemInterpretOnly%sCalcIndex(uint32_t uOpcode)' % (sInstrSet,),
                '{',
            ];
            assert sInstrSet in self.dRootsIndexExpr and len(self.dRootsIndexExpr[sInstrSet]); # Set by generateDecoderCpp!
            asLines += self.dRootsIndexExpr[sInstrSet];
            asLines += [
                '    return idx;',
                '}',
                '',
            ];
        asLines += [
            '#endif /* !VMM_INCLUDED_SRC_VMMAll_target_armv8_%s */' % (sBlockerName,),
            '',
        ];
        return (True, asLines);


    #
    # System registers
    #

    def generateCImplSysRegCpp(self, sInstrSet, sState):
        """ Worker for generateA64CImplSysRegCpp. """
        _ = sInstrSet;

        #
        # Gather the relevant system register access code.
        #
        dAccessors = {
            'A64.MRS':          SysRegGeneratorA64Mrs(),
            'A64.MSRregister':  SysRegGeneratorBase('A64.MSRregister',  'iemCImplA64_msr'),
            'A64.MSRimmediate': SysRegGeneratorBase('A64.MSRimmediate', 'iemCImplA64_msr_imm'),
            'A64.MRRS':         SysRegGeneratorBase('A64.MRRS',         'iemCImplA64_mrrs'),
            'A64.MSRRregister': SysRegGeneratorBase('A64.MSRRregister', 'iemCImplA64_msrr'),
        } # type: Dict[str,SysRegGeneratorBase]

        for oReg in spec.g_daoAllArmRegistersByState[sState]: # type: ArmRegister
            assert oReg.sState == sState;
            for oAccessor in oReg.aoAccessors:  # type: ArmAccessorBase
                if isinstance(oAccessor, spec.ArmAccessorSystem) and oAccessor.sName in dAccessors:
                    sEncSortKey = 'encoding=%s' % (oAccessor.oEncoding.dNamedValues,);
                    if (    not isinstance(oAccessor, spec.ArmAccessorSystemArray)
                        and not oAccessor.oEncoding.fHasWildcard
                        and not oAccessor.oEncoding.fHasIndex
                        and oAccessor.sName in ('A64.MRS', 'A64.MSRregister')):
                        sEncSortKey = oAccessor.oEncoding.getSysRegIdCreate();
                    dAccessors[oAccessor.sName].aoInfo.append(SysRegAccessorInfo(oAccessor, oReg, sEncSortKey));

        for sKey, oGenerator in dAccessors.items():
            assert sKey == oGenerator.sInstr;
            oGenerator.aoInfo.sort(key = operator.attrgetter('sEnc'));

        #
        # Morph the code into IEM suitable C code.
        #
        for oGenerator in dAccessors.values():
            for oInfo in oGenerator.aoInfo:
                if oInfo.sEnc[0] == 'A':
                    oGenerator.morphCodeToC(oInfo);
                    if oInfo.cIncompleteNodes > 0:
                        oGenerator.cIncomplete += 1;
                    else:
                        oGenerator.cComplete   += 1;
                    if oInfo.cAssignmentsWithUnresolvedRegs > 0:
                        oGenerator.cUnresolvedRegs += 1;

        #
        # File header.
        #
        asLines = self.generateLicenseHeader(spec.g_oArmRegistersVerInfo);
        asLines += [
            '#define LOG_GROUP LOG_GROUP_IEM',
            '#define VMCPU_INCL_CPUM_GST_CTX',
            '#include "IEMInternal.h"',
            '#include <VBox/vmm/vm.h>',
            '#include "VBox/err.h"',
            '',
            '#include "iprt/armv8.h"',
            '',
            '#include "IEMMc.h"',
            '#include "IEMInline-armv8.h"',
            '',
            '',
        ];

        #
        # Generate the real code, accessor type by accessor type.
        #
        for oGenerator in dAccessors.values():
            asLines += [
                '',
                '',
                '',
                '/*',
                ' * %s' % (oGenerator.sInstr,),
                ' *',
                ' * %4u registers' % (len(oGenerator.aoInfo),),
                ' * %4u complete - %u with unresolved registers'  % (oGenerator.cComplete, oGenerator.cUnresolvedRegs,),
                ' * %4u incomplete' % (oGenerator.cIncomplete,),
                ' */',
            ];

            # Individual handler functions.
            for oInfo in oGenerator.aoInfo:
                asLines.append('');
                if oInfo.sEnc[0] == 'A':
                    asLines += oGenerator.generateOneHandler(oInfo);
                else:
                    asLines += [
                        '// %s' % (oInfo.oAccessor.oEncoding.sAsmValue,),
                        '// %s' % (oInfo.sEnc,),
                    ];
                    if oInfo.oAccessor.oAccess:
                        asLines.extend(oInfo.oAccessor.oAccess.toStringList('//    '));
                    else:
                        asLines.append('// access is None!');

            # Main switch function.
            asLines += oGenerator.generateMainFunction();

        return (True, asLines);

    def generateA64CImplSysRegCpp(self, sFilename, iPartNo):
        """ Generates the IEMAllCImplA64SysReg-armv8.cpp file. """
        _ = sFilename; _ = iPartNo;
        return self.generateCImplSysRegCpp('A64', 'AArch64');


    #
    # Features
    #

    def generateFeaturesHdr(self, sFilename, iPartNo):
        _ = iPartNo;

        asLines = self.generateLicenseHeader(spec.g_oArmFeaturesVerInfo);
        sBlockerName = re.sub('[.-]', '_', os.path.basename(sFilename));
        asLines += [
            '#ifndef VMM_INCLUDED_SRC_VMMR3_target_armv8_%s' % (sBlockerName,),
            '#define VMM_INCLUDED_SRC_VMMR3_target_armv8_%s' % (sBlockerName,),
            '#ifndef RT_WITHOUT_PRAGMA_ONCE',
            '# pragma once',
            '#endif',
            '',
        ];

        #
        # Gather the features we're listing and sort it so that we start with
        # expressions only requiring a single system register value and move
        # on to more complicated ones, ending with those including other
        # FEAT_XXXX references (relies on sorting order).
        #
        aoFeatures = [oFeature for oFeature in spec.g_aoAllArmFeatures
                      if    oFeature.sName.startswith('FEAT_')
                        and oFeature.sName not in ('FEAT_EL0', 'FEAT_EL1', 'FEAT_EL2', 'FEAT_EL3') # removed in 2025
                        and oFeature.oSupportExpr
                        and oFeature.asSupportExprVars[0].split('.')[0] not in ('AArch32', 'PMU', 'AMU', 'ext', 'uext') ];
        aoFeatures = sorted(aoFeatures, key = lambda oFeature: (len(oFeature.asSupportExprVars), oFeature.asSupportExprVars));


        class CExprHelperFeatures(object):
            """ Helper class for creating C-expressions from the is-supported AST expressions. """
            def __init__(self):
                self.dVars        = {}      # Type: Dict[str, ArmRegister]
                self.idxFeatures  = 0;

            def _lookupSysRegValueExpr(self, oReg):
                return 'cpumCpuIdLookupSysReg(paSysRegs, cSysRegs, %s)' % (oReg.getVBoxConstant());

            def getFieldInfo(self, sName, sVar = '', sNamespace = ''):
                if sNamespace and sVar:
                    sCVarNm = 'u%s_%s' % (sNamespace, sVar)
                    oReg    = self.dVars.get(sCVarNm) # Type: ArmRegister
                    if not oReg:
                        oReg = spec.g_ddoAllArmRegistersByStateByName[sNamespace][sVar];
                        self.dVars[sCVarNm] = oReg;
                        # Warning! We're appending lines the output here!
                        asLines.append('');
                        asLines.append('    uint64_t const %s = %s;' % (sCVarNm, self._lookupSysRegValueExpr(oReg),));

                    aoFields = oReg.daoFields.get(sName);
                    if not aoFields:
                        raise Exception('Field %s was not found in register %s.%s (known fields: %s)'
                                        % (sName, sNamespace, sVar, oReg.daoFields.keys(),));
                    if len(aoFields) > 1:
                        raise Exception('Ambigious field %s was in register %s.%s: %s' % (sName, sNamespace, sVar, aoFields,));
                    oField = aoFields[0]    # Type: ArmFieldsBase

                    if len(oField.aoRanges) != 1:
                        raise Exception('TODO: Using complicated field %s in register %s.%s: %s'
                                        % (sName, sNamespace, sVar, oField.aoRanges,));
                    iFirstBit  = oField.aoRanges[0].iFirstBit;
                    cBitsWidth = oField.aoRanges[0].cBitsWidth;
                    if oField.oParent and isinstance(oField.oParent, spec.ArmFieldsConditionalField): # Relative to parent range.
                        if len(oField.oParent.aoRanges) != 1:
                            raise Exception('TODO: Using complicated conditional field %s in register %s.%s: %s'
                                            % (sName, sNamespace, sVar, oField.oParent.aoRanges,));
                        iFirstBit += oField.oParent.aoRanges[0].iFirstBit;
                        assert cBitsWidth <= oField.oParent.aoRanges[0].cBitsWidth;

                    return ('((%s >> %2u) & %#x /*%s*/)' % (sCVarNm, iFirstBit, (1 << cBitsWidth) - 1, sName,) , cBitsWidth);

                # We can deal with feature references, provided they're already initialized.
                # The sorting should take care of this, but we check. :)
                if sName.startswith('FEAT_'):
                    for i in range(self.idxFeatures):
                        if aoFeatures[i].sName == sName:
                            return ('pFeatures->%s' % (g_dSpecFeatToCpumFeat.get(sName, sName),), 1);
                    raise Exception('Internal error: Feature %s has not yet been initialized! (%s)'
                                    % (sName, ', '.join([aoFeatures[i].sName for i in range(self.idxFeatures)]),));

                # The v8Ap4 style stuff we just set to false for now.
                if sName in ('v8Ap4',):
                    return ('false', 1);

                ## @todo Need to load system registers.
                raise Exception('Field %s was not found ' % (sName,));

            def convertFunctionCall(self, oCall):
                if oCall.sName in ('UInt', 'SInt'):
                    if len(oCall.aoArgs) != 1:
                        raise Exception('Unexpected argument count for UInt call: %s' % (oCall.aoArgs,));
                    oArg = oCall.aoArgs[0] # ArmAstBase
                    if oCall.sName == 'UInt':
                        return '(uint32_t)(%s)' % (oArg.toCExpr(self),);
                    # Sign-extending a bit field requires us to know its size...
                    cBitsWidth = oArg.getWidth(self);
                    if cBitsWidth <= 0 or cBitsWidth >= 32:
                        raise Exception('Unexpected getWidth result for SInt argument: %s (%s)' % (cBitsWidth, oArg.toString()));
                    return '((int32_t)((uint32_t)(%s) << %u) >> %u)' % (oArg.toCExpr(self), 32 - cBitsWidth, 32 - cBitsWidth);

                raise Exception('Call to unsupported function: %s (%s)' % (oCall.sName, oCall.aoArgs,));

        asLines += [
            '',
            '',
            '/**',
            ' * Explodes ARMv8+ features from an array of system register values.',
            ' *',
            ' * @returns VBox status code',
            ' * @param   paSysRegs   The system registers and their values.',
            ' * @param   cSysRegs    Number of system register values.',
            ' * @param   pFeatures   The structure to explode the features into.',
            ' */',
            'VMMDECL(int) CPUMCpuIdExplodeFeaturesArmV8(PCSUPARMSYSREGVAL paSysRegs, uint32_t cSysRegs,',
            '                                           CPUMFEATURESARMV8 *pFeatures)',
            '{',
            '    RT_ZERO(*pFeatures);',
            '',
        ];
        asTodo  = []
        oHelper = CExprHelperFeatures();
        for oHelper.idxFeatures, oFeature in enumerate(aoFeatures):
            sFeatureMemberNm = g_dSpecFeatToCpumFeat.get(oFeature.sName, oFeature.sName);
            if sFeatureMemberNm is oFeature.sName:
                asTodo.append(oFeature.sName);

            print('debug: %s/%s <-> %s' % (oFeature.sName, sFeatureMemberNm, oFeature.oSupportExpr.toString()))
            sLine = '    pFeatures->%-22s = %s;' % (sFeatureMemberNm, oFeature.oSupportExpr.toCExpr(oHelper),)
            sLine = '%-116s /* %s */' % (sLine, oFeature.sName,);
            asLines.append(sLine);
        if asTodo:
            print('Error! Please add the features: %s' % (', '.join(asTodo),));
            for sFeature in asTodo:
                print('Error!   %-25s: %s -- %s'
                      % (sFeature, spec.g_dAllArmFeaturesByName[sFeature].asSupportExprVars,
                         ';  '.join(['#%u: %s' % (iExpr, oExpr.toString())
                                     for iExpr, oExpr in enumerate(spec.g_dAllArmFeaturesByName[sFeature].aoConstraints)]),));

        # Did we miss any features in CPUMFEATURESARMV8?
        asMissing = [];
        hsMissingFeatures = set(g_dSpecFeatToCpumFeat) - set({oFeature.sName for oFeature in aoFeatures});
        if hsMissingFeatures:
            print('Error! The following CPUMFEATURESARMV8 members have not been initialized: %s'
                  % (', '.join(hsMissingFeatures),));
            asMissing += [
                '',
                '    /* Initializing "missing" members: */',
            ];
            for sFeature in sorted(hsMissingFeatures):
                oFeature = spec.g_dAllArmFeaturesByName.get(sFeature)
                if oFeature:
                    sExtra = ' (%s)' % ('; '.join(['#%u: %s' % (iExpr, oExpr.toString())
                                                   for iExpr, oExpr in enumerate(oFeature.aoConstraints)]),);
                else:
                    sExtra = '';
                asMissing.append('    pFeatures->%-22s = 0; /* %s%s */' % (g_dSpecFeatToCpumFeat[sFeature], sFeature, sExtra));

        asLines += asMissing;

        asLines += [
            '',
            '    return cpumCpuIdExplodeFeaturesArmV8Handcoded(paSysRegs, cSysRegs, pFeatures);',
            '}'
        ];

        #
        # Write a dumper function for the CPUMFEATURESARMV8 structure.
        #
        cchMaxFeatNm = max(len(sKey) for sKey in g_dSpecFeatToCpumFeat);
        asLines += [
            '',
            '#ifdef IN_RING3',
            '',
            '# include <VBox/vmm/dbgf.h> /* DBGFINFOHLP */',
            '',
            '/**',
            ' * Prints the ARMv8+ features in @a pFeatures.',
            ' *',
            ' * @param   pHlp            The output callback helper.',
            ' * @param   cchOutput       The width of the output (for multiple columns).',
            ' *                          Zero is taken to mean a single column.',
            ' * @param   pFeatures       The features to dump',
            ' * @param   pszLabel        The label.',
            ' * @param   pSecondary      Optional secondary feature set to compare with.',
            ' * @param   pszSecondary    The label for the secondary feature set.',
            ' */',
            'VMMR3DECL(void) CPUMR3CpuIdPrintArmV8Features(PCDBGFINFOHLP pHlp, uint32_t cchOutput,',
            '                                              CPUMFEATURESARMV8 const *pFeatures, const char *pszLabel,',
            '                                              CPUMFEATURESARMV8 const *pSecondary, const char *pszSecondary)',
            '{',
            '    unsigned const cchLabel  = (unsigned)strlen(pszLabel);',
            '    unsigned const cchLabel2 = pszSecondary ? (unsigned)strlen(pszSecondary) : 0;',
            '    unsigned const cchPad    = cchLabel - 1 + cchLabel2 - !!cchLabel2;',
            '    unsigned const cchColumn = 2 + %s + 3 + cchLabel + (pSecondary ? 3 + cchLabel2 : 0);' % (cchMaxFeatNm,),
            '    unsigned const cColumns  = cchOutput < cchColumn ? 1 : cchOutput / cchColumn;',
            '    if (pSecondary)',
            '        for (unsigned iColumn = 0; iColumn < cColumns; iColumn++)',
            '            pHlp->pfnPrintf(pHlp, "  %%%us = %%s (%%s)", "Features", pszLabel, pszSecondary);' % (cchMaxFeatNm,),
            '    else',
            '        for (unsigned iColumn = 0; iColumn < cColumns; iColumn++)',
            '            pHlp->pfnPrintf(pHlp, "  %%%us = %%s", "Features", pszLabel);' % (cchMaxFeatNm,),
            '    pHlp->pfnPrintf(pHlp, "\\n");',
            '',
            '    unsigned iColumn = 0;',
            '#define PRINT_FEATURE(a_Name, a_Member) do { \\',
            '            if (pSecondary) \\',
            '                pHlp->pfnPrintf(pHlp, "%%*s  %%%us = %%u (%%u)", \\' % (cchMaxFeatNm,),
            '                                iColumn ? cchPad : 0, "", #a_Name, pFeatures->a_Member, pSecondary->a_Member); \\',
            '            else \\',
            '                pHlp->pfnPrintf(pHlp, "%%*s  %%%us = %%u", \\' % (cchMaxFeatNm,),
            '                                iColumn ? cchPad : 0, "", #a_Name, pFeatures->a_Member); \\',
            '            iColumn += 1; \\',
            '            if (iColumn >= cColumns) \\',
            '            { \\',
            '                pHlp->pfnPrintf(pHlp, "\\n"); \\',
            '                iColumn = 0; \\',
            '            } \\',
            '        } while (0)',
        ];

        asLines.extend(['    PRINT_FEATURE(%-*s %s);' % (cchMaxFeatNm + 1, sFeature + ',', g_dSpecFeatToCpumFeat[sFeature])
                        for sFeature in sorted(g_dSpecFeatToCpumFeat.keys())]);
        asLines += [
            '}',
            '#endif /* IN_RING3 */',
        ];


        asLines += [
            '',
            '#endif /* !VMM_INCLUDED_SRC_VMMR3_target_armv8_%s */' % (sBlockerName,),
            '',
        ];
        return (not(asTodo), asLines);


    def main(self, asArgs):
        """ Main function. """

        #
        # Parse arguments.
        #
        class MyArgParser(argparse.ArgumentParser):
            def convert_arg_line_to_args(self, arg_line):
                return arg_line.split();

        oArgParser = MyArgParser(fromfile_prefix_chars = '@',
                                 formatter_class = argparse.RawDescriptionHelpFormatter,
                                 epilog = '''
Hints can be extracted from existing code with the following sed command:
    kmk_sed -e "/--decoder-hint/!d" -e "s/^...//" IEMAllIntprA64Tables-armv8.cpp > hints.rsp
Then add @hints.rsp to the command line to make use of them.''');
        oArgParser.add_argument('--tar',
                                metavar = 'AARCHMRS_BSD_A_profile-2024-12.tar.gz',
                                dest    = 'sTarFile',
                                action  = 'store',
                                default = None,
                                help    = 'Specification TAR file to get the files from.');
        oArgParser.add_argument('--instructions',
                                metavar = 'Instructions.json',
                                dest    = 'sFileInstructions',
                                action  = 'store',
                                default = 'Instructions.json',
                                help    = 'The path to the instruction specficiation file.');
        oArgParser.add_argument('--features',
                                metavar = 'Features.json',
                                dest    = 'sFileFeatures',
                                action  = 'store',
                                default = 'Features.json',
                                help    = 'The path to the features specficiation file.');
        oArgParser.add_argument('--registers',
                                metavar = 'Registers.json',
                                dest    = 'sFileRegisters',
                                action  = 'store',
                                default = 'Registers.json',
                                help    = 'The path to the registers specficiation file.');
        oArgParser.add_argument('--spec-dir',
                                metavar = 'dir',
                                dest    = 'sSpecDir',
                                action  = 'store',
                                default = '',
                                help    = 'Specification directory to prefix the specficiation files with.');
        oArgParser.add_argument('--out-decoder-cpp',
                                metavar = 'file-decoder.cpp',
                                dest    = 'sFileDecoderCpp',
                                action  = 'store',
                                default = None,
                                help    = 'The output C++ file for the decoder.');
        oArgParser.add_argument('--out-decoder-hdr',
                                metavar = 'file-decoder.h',
                                dest    = 'sFileDecoderHdr',
                                action  = 'store',
                                default = None,
                                help    = 'The output header file for the decoder.');
        oArgParser.add_argument('--out-stub-hdr',
                                metavar = 'file-stub.h',
                                dest    = 'sFileStubHdr',
                                action  = 'store',
                                default = None,
                                help    = 'The output header file for the implementation stubs.');
        oArgParser.add_argument('--out-cimpl-sysreg-cpp',
                                metavar = 'file-cimpl-sysreg.cpp',
                                dest    = 'sFileCImplSysRegCpp',
                                action  = 'store',
                                default = None,
                                help    = 'The output C++ file for system register handling (MRS, MSR, ++).');
        oArgParser.add_argument('--out-features-hdr',
                                metavar = 'file-features.h',
                                dest    = 'sFileFeaturesHdr',
                                action  = 'store',
                                default = None,
                                help    = 'The output header file for the feature extraction & dumping code.');

        # debug:
        oArgParser.add_argument('--print-instructions',
                                dest    = 'fPrintInstructions',
                                action  = 'store_true',
                                default = False,
                                help    = 'List the instructions after loading.');
        oArgParser.add_argument('--print-instructions-with-conditions',
                                dest    = 'fPrintInstructionsWithConds',
                                action  = 'store_true',
                                default = False,
                                help    = 'List the instructions and conditions after loading.');
        oArgParser.add_argument('--print-instructions-with-encoding',
                                dest    = 'fPrintInstructionsWithEncoding',
                                action  = 'store_true',
                                default = False,
                                help    = 'List the instructions and encoding details after loading.');
        oArgParser.add_argument('--print-fixed-mask-stats',
                                dest    = 'fPrintFixedMaskStats',
                                action  = 'store_true',
                                default = False,
                                help    = 'List statistics on fixed bit masks.');
        oArgParser.add_argument('--print-fixed-mask-top-10',
                                dest    = 'fPrintFixedMaskTop10',
                                action  = 'store_true',
                                default = False,
                                help    = 'List the 10 top fixed bit masks.');
        oArgParser.add_argument('--print-sysregs',
                                dest    = 'fPrintSysRegs',
                                action  = 'store_true',
                                default = False,
                                help    = 'List system registers after loading.');
        # Hacks
        oArgParser.add_argument('--decoder-hint0',
                                metavar = 'mask-to-use',
                                dest    = 'asDecoderHintsL0',
                                action  = 'append',
                                default = [],
                                help    = 'Top level decoder hints used to shorten the runtime. Format: <mask-to-use>');
        oArgParser.add_argument('--decoder-hint1',
                                metavar = 'matched-mask/value/mask-to-use',
                                dest    = 'asDecoderHintsL1',
                                action  = 'append',
                                default = [],
                                help    = 'Level 1 decoder hints. Format: <matched-mask>/<matched-value/<mask-to-use>');
        oArgParser.add_argument('--decoder-hint1-threshold',
                                metavar = 'count',
                                dest    = 'iDecoderL1Threshold',
                                type    = int,
                                action  = 'store',
                                default = 20,
                                help    = 'The instruction threshold count for emitting --decoder-hint1 in the generated code.');

        # Do it!
        oOptions = oArgParser.parse_args(asArgs[1:]);
        self.oOptions = oOptions;

        # Process the decoder hints.
        for sValue in oOptions.asDecoderHintsL0:
            try:
                fTmp = int(sValue, 16);
                if fTmp <= 0 or fTmp >= 0x100000000 or fTmp.bit_count() <= 4 or fTmp.bit_count() >= 16:# pylint: disable=no-member
                    raise Exception();
            except:
                print('syntax error: Invalid --decoder-hint0 value: %s' % (sValue,))
                return 2;
            g_dDecoderFilterDepth0[fTmp] = True;

        for sValue in oOptions.asDecoderHintsL1:
            try:
                afVals = [int(sSub, 16) for sSub in sValue.split('/')];
                for iVal, fTmp in enumerate(afVals):
                    if fTmp < 0 or fTmp >= 0x100000000 or (fTmp == 0 and iVal != 1): raise Exception();
                if (afVals[0] & afVals[1]) != afVals[1] or (afVals[0] & afVals[2]) != 0: raise Exception();
            except:
                print('syntax error: Invalid --decoder-hint1 value: %s' % (sValue,))
                return 2;
            sKey = '%x/%x' % (afVals[0], afVals[1]);
            if sKey not in g_ddDecoderFilterDepth1:
                g_ddDecoderFilterDepth1[sKey] = {afVals[2]: True,};
            else:
                g_ddDecoderFilterDepth1[sKey][afVals[2]] = True;

        #
        # Load the specification.
        #
        if oOptions.sTarFile:
            fRc = spec.loadArmOpenSourceSpecificationFromTar(oOptions.sTarFile, oOptions.sFileInstructions,
                                                             oOptions.sFileFeatures, oOptions.sFileRegisters);
        elif oOptions.sSpecDir:
            fRc = spec.loadArmOpenSourceSpecificationFromDir(oOptions.sSpecDir, oOptions.sFileInstructions,
                                                             oOptions.sFileFeatures, oOptions.sFileRegisters);
        else:
            fRc = spec.loadArmOpenSourceSpecificationFromFiles(oOptions.sFileInstructions, oOptions.sFileFeatures,
                                                               oOptions.sFileRegisters);
        if fRc:
            spec.printSpecs(fPrintInstructions               = oOptions.fPrintInstructions,
                            fPrintInstructionsWithEncoding   = oOptions.fPrintInstructionsWithEncoding,
                            fPrintInstructionsWithConds      = oOptions.fPrintInstructionsWithConds,
                            fPrintFixedMaskStats             = oOptions.fPrintFixedMaskStats,
                            fPrintFixedMaskTop10             = oOptions.fPrintFixedMaskTop10,
                            fPrintSysRegs                    = oOptions.fPrintSysRegs);

            #
            # Check if we're generating any output before constructing the decoder.
            #
            aaoOutputFiles = [
                 ( oOptions.sFileDecoderCpp,      self.generateA64DecoderCpp,            0, 1, ),
                 ( oOptions.sFileDecoderHdr,      self.generateDecoderHdr,               0, 1, ), # after generateA64DecoderCpp!
                 ( oOptions.sFileStubHdr,         self.generateA64ImplementationStubHdr, 0, 1, ),
                 ( oOptions.sFileCImplSysRegCpp,  self.generateA64CImplSysRegCpp,        0, 0, ),
                 ( oOptions.sFileFeaturesHdr,     self.generateFeaturesHdr,              0, 0, ),
            ];

            cOutputFiles        = 0;
            cDecoderOutputFiles = 0;
            for sOutFile, _, _, fDecoder in aaoOutputFiles:
                cOutputFiles        += sOutFile is not None;
                cDecoderOutputFiles += sOutFile is not None and fDecoder;

            fRc = True;
            if cOutputFiles > 0:
                #
                # Sort out the decoding if needed.
                #
                if cDecoderOutputFiles > 0:
                    self.constructDecoder();

                #
                # Output.
                #
                for sOutFile, fnGenMethod, iPartNo, _ in aaoOutputFiles:
                    if not sOutFile:
                        continue;
                    (fRc2, asLines) = fnGenMethod(sOutFile, iPartNo);
                    fRc = fRc2 and fRc;

                    if sOutFile == '-':
                        sys.stdout.write('\n'.join(asLines));
                    else:
                        try:
                            oOut = open(sOutFile, 'w', encoding = 'utf-8', errors = 'strict');
                        except Exception as oXcpt:
                            print('error! Failed open "%s" for writing: %s' % (sOutFile, oXcpt,), file = sys.stderr);
                            return 1;
                        with oOut:
                            oOut.write('\n'.join(asLines));
            if fRc:
                return 0;

        return 1;

if __name__ == '__main__':
    sys.exit(pycmn.mainWrapperCatchXcptAndDoProfiling(IEMArmGenerator().main));

