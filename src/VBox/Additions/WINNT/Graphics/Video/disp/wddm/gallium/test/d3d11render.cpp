/* $Id$ */
/** @file
 * Gallium D3D testcase. Simple D3D11 tests.
 */

/*
 * Copyright (C) 2017-2023 Oracle and/or its affiliates.
 *
 * This file is part of VirtualBox base platform packages, as
 * available from https://www.virtualbox.org.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, in version 3 of the
 * License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <https://www.gnu.org/licenses>.
 *
 * SPDX-License-Identifier: GPL-3.0-only
 */

#include "d3d11render.h"

#include <iprt/file.h>
#include <iprt/formats/bmp.h>

#if 0
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//
//   fxc /Fhd3d11color.hlsl.vs.h /Evs_color /Tvs_4_0 d3d11color.hlsl
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue Format   Used
// -------------------- ----- ------ -------- -------- ------ ------
// POSITION                 0   xyz         0     NONE  float   xyz
// COLOR                    0   xyzw        1     NONE  float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue Format   Used
// -------------------- ----- ------ -------- -------- ------ ------
// SV_POSITION              0   xyzw        0      POS  float   xyzw
// COLOR                    0   xyzw        1     NONE  float   xyzw
//
vs_4_0
dcl_input v0.xyz
dcl_input v1.xyzw
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
mov o0.xyz, v0.xyzx
mov o0.w, l(1.000000)
mov o1.xyzw, v1.xyzw
ret
// Approximately 4 instruction slots used
#endif

static BYTE const g_vs_color[] =
{
     68,  88,  66,  67, 109, 138, 105,  83,  86, 190,  83, 125,  72, 102, 194, 136,  46,  69,
     17, 121,   1,   0,   0,   0,  48,   2,   0,   0,   5,   0,   0,   0,  52,   0,   0,   0,
    140,   0,   0,   0, 220,   0,   0,   0,  48,   1,   0,   0, 180,   1,   0,   0,  82,  68,
     69,  70,  80,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
     28,   0,   0,   0,   0,   4, 254, 255,   0,   1,   0,   0,  28,   0,   0,   0,  77, 105,
     99, 114, 111, 115, 111, 102, 116,  32,  40,  82,  41,  32,  72,  76,  83,  76,  32,  83,
    104,  97, 100, 101, 114,  32,  67, 111, 109, 112, 105, 108, 101, 114,  32,  57,  46,  50,
     57,  46,  57,  53,  50,  46,  51,  49,  49,  49,   0, 171, 171, 171,  73,  83,  71,  78,
     72,   0,   0,   0,   2,   0,   0,   0,   8,   0,   0,   0,  56,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,   7,   7,   0,   0,
     65,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   1,   0,
      0,   0,  15,  15,   0,   0,  80,  79,  83,  73,  84,  73,  79,  78,   0,  67,  79,  76,
     79,  82,   0, 171,  79,  83,  71,  78,  76,   0,   0,   0,   2,   0,   0,   0,   8,   0,
      0,   0,  56,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   3,   0,   0,   0,
      0,   0,   0,   0,  15,   0,   0,   0,  68,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   3,   0,   0,   0,   1,   0,   0,   0,  15,   0,   0,   0,  83,  86,  95,  80,
     79,  83,  73,  84,  73,  79,  78,   0,  67,  79,  76,  79,  82,   0, 171, 171,  83,  72,
     68,  82, 124,   0,   0,   0,  64,   0,   1,   0,  31,   0,   0,   0,  95,   0,   0,   3,
    114,  16,  16,   0,   0,   0,   0,   0,  95,   0,   0,   3, 242,  16,  16,   0,   1,   0,
      0,   0, 103,   0,   0,   4, 242,  32,  16,   0,   0,   0,   0,   0,   1,   0,   0,   0,
    101,   0,   0,   3, 242,  32,  16,   0,   1,   0,   0,   0,  54,   0,   0,   5, 114,  32,
     16,   0,   0,   0,   0,   0,  70,  18,  16,   0,   0,   0,   0,   0,  54,   0,   0,   5,
    130,  32,  16,   0,   0,   0,   0,   0,   1,  64,   0,   0,   0,   0, 128,  63,  54,   0,
      0,   5, 242,  32,  16,   0,   1,   0,   0,   0,  70,  30,  16,   0,   1,   0,   0,   0,
     62,   0,   0,   1,  83,  84,  65,  84, 116,   0,   0,   0,   4,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0
};

#if 0
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//
//   fxc /Fhd3d11color.hlsl.ps.h /Eps_color /Tps_4_0 d3d11color.hlsl
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue Format   Used
// -------------------- ----- ------ -------- -------- ------ ------
// SV_POSITION              0   xyzw        0      POS  float
// COLOR                    0   xyzw        1     NONE  float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue Format   Used
// -------------------- ----- ------ -------- -------- ------ ------
// SV_TARGET                0   xyzw        0   TARGET  float   xyzw
//
ps_4_0
dcl_input_ps linear v1.xyzw
dcl_output o0.xyzw
mov o0.xyzw, v1.xyzw
ret
// Approximately 2 instruction slots used
#endif

static BYTE const g_ps_color[] =
{
     68,  88,  66,  67, 206, 120, 117, 238, 118, 127,  10,  87,  80,  75, 114, 198,  95,   2,
    120, 102,   1,   0,   0,   0, 208,   1,   0,   0,   5,   0,   0,   0,  52,   0,   0,   0,
    140,   0,   0,   0, 224,   0,   0,   0,  20,   1,   0,   0,  84,   1,   0,   0,  82,  68,
     69,  70,  80,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
     28,   0,   0,   0,   0,   4, 255, 255,   0,   1,   0,   0,  28,   0,   0,   0,  77, 105,
     99, 114, 111, 115, 111, 102, 116,  32,  40,  82,  41,  32,  72,  76,  83,  76,  32,  83,
    104,  97, 100, 101, 114,  32,  67, 111, 109, 112, 105, 108, 101, 114,  32,  57,  46,  50,
     57,  46,  57,  53,  50,  46,  51,  49,  49,  49,   0, 171, 171, 171,  73,  83,  71,  78,
     76,   0,   0,   0,   2,   0,   0,   0,   8,   0,   0,   0,  56,   0,   0,   0,   0,   0,
      0,   0,   1,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,
     68,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   1,   0,
      0,   0,  15,  15,   0,   0,  83,  86,  95,  80,  79,  83,  73,  84,  73,  79,  78,   0,
     67,  79,  76,  79,  82,   0, 171, 171,  79,  83,  71,  78,  44,   0,   0,   0,   1,   0,
      0,   0,   8,   0,   0,   0,  32,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      3,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,  83,  86,  95,  84,  65,  82,
     71,  69,  84,   0, 171, 171,  83,  72,  68,  82,  56,   0,   0,   0,  64,   0,   0,   0,
     14,   0,   0,   0,  98,  16,   0,   3, 242,  16,  16,   0,   1,   0,   0,   0, 101,   0,
      0,   3, 242,  32,  16,   0,   0,   0,   0,   0,  54,   0,   0,   5, 242,  32,  16,   0,
      0,   0,   0,   0,  70,  30,  16,   0,   1,   0,   0,   0,  62,   0,   0,   1,  83,  84,
     65,  84, 116,   0,   0,   0,   2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

typedef enum {
   SVGA3D_BLENDOP_INVALID             = 0,
   SVGA3D_BLENDOP_MIN                 = 1,
   SVGA3D_BLENDOP_ZERO                = 1,
   SVGA3D_BLENDOP_ONE                 = 2,
   SVGA3D_BLENDOP_SRCCOLOR            = 3,
   SVGA3D_BLENDOP_INVSRCCOLOR         = 4,
   SVGA3D_BLENDOP_SRCALPHA            = 5,
   SVGA3D_BLENDOP_INVSRCALPHA         = 6,
   SVGA3D_BLENDOP_DESTALPHA           = 7,
   SVGA3D_BLENDOP_INVDESTALPHA        = 8,
   SVGA3D_BLENDOP_DESTCOLOR           = 9,
   SVGA3D_BLENDOP_INVDESTCOLOR        = 10,
   SVGA3D_BLENDOP_SRCALPHASAT         = 11,
   SVGA3D_BLENDOP_BLENDFACTOR         = 12,
   SVGA3D_BLENDOP_INVBLENDFACTOR      = 13,
   SVGA3D_BLENDOP_SRC1COLOR           = 14,
   SVGA3D_BLENDOP_INVSRC1COLOR        = 15,
   SVGA3D_BLENDOP_SRC1ALPHA           = 16,
   SVGA3D_BLENDOP_INVSRC1ALPHA        = 17,
   SVGA3D_BLENDOP_BLENDFACTORALPHA    = 18,
   SVGA3D_BLENDOP_INVBLENDFACTORALPHA = 19,
   SVGA3D_BLENDOP_MAX
} SVGA3dBlendOp;

static D3D11_BLEND dxBlendFactorAlpha(uint8_t svgaBlend)
{
    /* "Blend options that end in _COLOR are not allowed." but the guest sometimes sends them. */
    switch (svgaBlend)
    {
        case SVGA3D_BLENDOP_ZERO:                return D3D11_BLEND_ZERO;
        case SVGA3D_BLENDOP_ONE:                 return D3D11_BLEND_ONE;
        case SVGA3D_BLENDOP_SRCCOLOR:            return D3D11_BLEND_SRC_ALPHA;
        case SVGA3D_BLENDOP_INVSRCCOLOR:         return D3D11_BLEND_INV_SRC_ALPHA;
        case SVGA3D_BLENDOP_SRCALPHA:            return D3D11_BLEND_SRC_ALPHA;
        case SVGA3D_BLENDOP_INVSRCALPHA:         return D3D11_BLEND_INV_SRC_ALPHA;
        case SVGA3D_BLENDOP_DESTALPHA:           return D3D11_BLEND_DEST_ALPHA;
        case SVGA3D_BLENDOP_INVDESTALPHA:        return D3D11_BLEND_INV_DEST_ALPHA;
        case SVGA3D_BLENDOP_DESTCOLOR:           return D3D11_BLEND_DEST_ALPHA;
        case SVGA3D_BLENDOP_INVDESTCOLOR:        return D3D11_BLEND_INV_DEST_ALPHA;
        case SVGA3D_BLENDOP_SRCALPHASAT:         return D3D11_BLEND_SRC_ALPHA_SAT;
        case SVGA3D_BLENDOP_BLENDFACTOR:         return D3D11_BLEND_BLEND_FACTOR;
        case SVGA3D_BLENDOP_INVBLENDFACTOR:      return D3D11_BLEND_INV_BLEND_FACTOR;
        case SVGA3D_BLENDOP_SRC1COLOR:           return D3D11_BLEND_SRC1_ALPHA;
        case SVGA3D_BLENDOP_INVSRC1COLOR:        return D3D11_BLEND_INV_SRC1_ALPHA;
        case SVGA3D_BLENDOP_SRC1ALPHA:           return D3D11_BLEND_SRC1_ALPHA;
        case SVGA3D_BLENDOP_INVSRC1ALPHA:        return D3D11_BLEND_INV_SRC1_ALPHA;
        case SVGA3D_BLENDOP_BLENDFACTORALPHA:    return D3D11_BLEND_BLEND_FACTOR;
        case SVGA3D_BLENDOP_INVBLENDFACTORALPHA: return D3D11_BLEND_INV_BLEND_FACTOR;
        default:
            break;
    }
    return D3D11_BLEND_ZERO;
}


static D3D11_BLEND dxBlendFactorColor(uint8_t svgaBlend)
{
    switch (svgaBlend)
    {
        case SVGA3D_BLENDOP_ZERO:                return D3D11_BLEND_ZERO;
        case SVGA3D_BLENDOP_ONE:                 return D3D11_BLEND_ONE;
        case SVGA3D_BLENDOP_SRCCOLOR:            return D3D11_BLEND_SRC_COLOR;
        case SVGA3D_BLENDOP_INVSRCCOLOR:         return D3D11_BLEND_INV_SRC_COLOR;
        case SVGA3D_BLENDOP_SRCALPHA:            return D3D11_BLEND_SRC_ALPHA;
        case SVGA3D_BLENDOP_INVSRCALPHA:         return D3D11_BLEND_INV_SRC_ALPHA;
        case SVGA3D_BLENDOP_DESTALPHA:           return D3D11_BLEND_DEST_ALPHA;
        case SVGA3D_BLENDOP_INVDESTALPHA:        return D3D11_BLEND_INV_DEST_ALPHA;
        case SVGA3D_BLENDOP_DESTCOLOR:           return D3D11_BLEND_DEST_COLOR;
        case SVGA3D_BLENDOP_INVDESTCOLOR:        return D3D11_BLEND_INV_DEST_COLOR;
        case SVGA3D_BLENDOP_SRCALPHASAT:         return D3D11_BLEND_SRC_ALPHA_SAT;
        case SVGA3D_BLENDOP_BLENDFACTOR:         return D3D11_BLEND_BLEND_FACTOR;
        case SVGA3D_BLENDOP_INVBLENDFACTOR:      return D3D11_BLEND_INV_BLEND_FACTOR;
        case SVGA3D_BLENDOP_SRC1COLOR:           return D3D11_BLEND_SRC1_COLOR;
        case SVGA3D_BLENDOP_INVSRC1COLOR:        return D3D11_BLEND_INV_SRC1_COLOR;
        case SVGA3D_BLENDOP_SRC1ALPHA:           return D3D11_BLEND_SRC1_ALPHA;
        case SVGA3D_BLENDOP_INVSRC1ALPHA:        return D3D11_BLEND_INV_SRC1_ALPHA;
        case SVGA3D_BLENDOP_BLENDFACTORALPHA:    return D3D11_BLEND_BLEND_FACTOR;
        case SVGA3D_BLENDOP_INVBLENDFACTORALPHA: return D3D11_BLEND_INV_BLEND_FACTOR;
        default:
            break;
    }
    return D3D11_BLEND_ZERO;
}

static D3D11_BLEND_OP dxBlendOp(uint8_t svgaBlendEq)
{
    return (D3D11_BLEND_OP)svgaBlendEq;
}

typedef enum {
   SVGA3D_FILLMODE_INVALID = 0,
   SVGA3D_FILLMODE_MIN     = 1,
   SVGA3D_FILLMODE_POINT   = 1,
   SVGA3D_FILLMODE_LINE    = 2,
   SVGA3D_FILLMODE_FILL    = 3,
   SVGA3D_FILLMODE_MAX
} SVGA3dFillModeType;

static D3D11_FILL_MODE dxFillMode(uint8_t svgaFillMode)
{
    if (svgaFillMode == SVGA3D_FILLMODE_POINT)
        return D3D11_FILL_WIREFRAME;
    return (D3D11_FILL_MODE)svgaFillMode;
}

/*
 * Clear the backbuffer and display it.
 */

class D3D11RenderClear: public D3D11Render
{
public:
    D3D11RenderClear() {}
    virtual ~D3D11RenderClear() {}
    virtual HRESULT InitRender(D3D11DeviceProvider *pDP);
    virtual HRESULT DoRender(D3D11DeviceProvider *pDP);
};

HRESULT D3D11RenderClear::InitRender(D3D11DeviceProvider *pDP)
{
    (void)pDP;
    return S_OK;
}

HRESULT D3D11RenderClear::DoRender(D3D11DeviceProvider *pDP)
{
    ID3D11DeviceContext *pImmediateContext = pDP->ImmediateContext();

    FLOAT aColor[4] = { 1.0f, 0.0f, 0.0f, 0.0f };
    pImmediateContext->ClearRenderTargetView(pDP->RenderTargetView(), aColor);

    return S_OK;
}

/*
 * Simplest colorful triangle using shaders.
 */

class D3D11RenderTriangleShader: public D3D11Render
{
public:
    D3D11RenderTriangleShader();
    virtual ~D3D11RenderTriangleShader();
    virtual HRESULT InitRender(D3D11DeviceProvider *pDP);
    virtual HRESULT DoRender(D3D11DeviceProvider *pDP);
private:
    ID3D11InputLayout *mpInputLayout;
    ID3D11VertexShader *mpVS;
    ID3D11PixelShader *mpPS;
    ID3D11Buffer *mpVB;

    struct Vertex
    {
        float position[3];
        float color[4];
    };
};


D3D11RenderTriangleShader::D3D11RenderTriangleShader()
    : mpInputLayout(0)
    , mpVS(0)
    , mpPS(0)
    , mpVB(0)
{
}

D3D11RenderTriangleShader::~D3D11RenderTriangleShader()
{
    D3D_RELEASE(mpInputLayout);
    D3D_RELEASE(mpVS);
    D3D_RELEASE(mpPS);
    D3D_RELEASE(mpVB);
}

HRESULT D3D11RenderTriangleShader::InitRender(D3D11DeviceProvider *pDP)
{
    ID3D11Device *pDevice = pDP->Device();

    static D3D11_INPUT_ELEMENT_DESC const aVertexDesc[] =
    {
        {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
        {"COLOR",    0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}
    };

    static Vertex const aVertices[] =
    {
        { { -0.5f, -0.5f, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f }, },
        { {  0.0f,  0.5f, 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f }, },
        { {  0.5f, -0.5f, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f }, },
    };

    HRESULT hr = S_OK;

    HTEST(pDevice->CreateInputLayout(aVertexDesc, RT_ELEMENTS(aVertexDesc),
          &g_vs_color[0], sizeof(g_vs_color),
          &mpInputLayout));
    HTEST(pDevice->CreateVertexShader(g_vs_color, sizeof(g_vs_color), NULL, &mpVS));
    HTEST(pDevice->CreatePixelShader(g_ps_color, sizeof(g_ps_color), NULL, &mpPS));

    D3D11_BUFFER_DESC vbd;
    RT_ZERO(vbd);
    vbd.Usage               = D3D11_USAGE_IMMUTABLE;
    vbd.ByteWidth           = sizeof(aVertices);
    vbd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags      = 0;
    vbd.MiscFlags           = 0;
    vbd.StructureByteStride = 0;

    D3D11_SUBRESOURCE_DATA vinitData;
    RT_ZERO(vinitData);
    vinitData.pSysMem = aVertices;

    HTEST(pDevice->CreateBuffer(&vbd, &vinitData, &mpVB));

    return hr;
}

HRESULT D3D11RenderTriangleShader::DoRender(D3D11DeviceProvider *pDP)
{
    ID3D11DeviceContext *pImmediateContext = pDP->ImmediateContext();

    FLOAT aColor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
    pImmediateContext->ClearRenderTargetView(pDP->RenderTargetView(), aColor);
    if (pDP->DepthStencilView())
        pImmediateContext->ClearDepthStencilView(pDP->DepthStencilView(),
                                                 D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    pImmediateContext->IASetInputLayout(mpInputLayout);
    pImmediateContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    pImmediateContext->IASetVertexBuffers(0, 1, &mpVB, &stride, &offset);

    pImmediateContext->VSSetShader(mpVS, NULL, 0);
    pImmediateContext->PSSetShader(mpPS, NULL, 0);

    D3D11_VIEWPORT Viewport;
    Viewport.TopLeftX = 0.0f;
    Viewport.TopLeftY = 0.0f;
    Viewport.Width    = (float)800;
    Viewport.Height   = (float)600;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    pImmediateContext->RSSetViewports(1, &Viewport);

    pImmediateContext->Draw(3, 0);

    return S_OK;
}



/*
 * Two vertex streams from either a single vertex buffer or two vertex buffers.
 */

class D3D11RenderDoubleVB: public D3D11Render
{
public:
    D3D11RenderDoubleVB(bool fUseSameBuffer);
    virtual ~D3D11RenderDoubleVB();
    virtual HRESULT InitRender(D3D11DeviceProvider *pDP);
    virtual HRESULT DoRender(D3D11DeviceProvider *pDP);
private:
    bool mfUseSameBuffer;

    ID3D11InputLayout *mpInputLayout;
    ID3D11VertexShader *mpVS;
    ID3D11PixelShader *mpPS;
    ID3D11Buffer *mapVB[2];

    static const size_t mcbGap;

    struct Vertex1
    {
        float position[3];
    };

    struct Vertex2
    {
        float color[4];
    };
};

const size_t D3D11RenderDoubleVB::mcbGap = 16;

D3D11RenderDoubleVB::D3D11RenderDoubleVB(bool fUseSameBuffer)
    : mfUseSameBuffer(fUseSameBuffer)
    , mpInputLayout(0)
    , mpVS(0)
    , mpPS(0)
{
    RT_ZERO(mapVB);
}

D3D11RenderDoubleVB::~D3D11RenderDoubleVB()
{
    D3D_RELEASE(mpInputLayout);
    D3D_RELEASE(mpVS);
    D3D_RELEASE(mpPS);
    D3D_RELEASE(mapVB[0]);
    D3D_RELEASE(mapVB[1]);
}

HRESULT D3D11RenderDoubleVB::InitRender(D3D11DeviceProvider *pDP)
{
    ID3D11Device *pDevice = pDP->Device();

    static D3D11_INPUT_ELEMENT_DESC const aVertexDesc[] =
    {
        {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
        {"COLOR",    0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}
    };

    static Vertex1 const aVertices1[] =
    {
        { { -0.5f, -0.5f, 0.0f } },
        { {  0.0f,  0.5f, 0.0f } },
        { {  0.5f, -0.5f, 0.0f } },
    };

    static Vertex2 const aVertices2[] =
    {
        { { 0.0f, 0.0f, 1.0f, 1.0f } },
        { { 0.0f, 1.0f, 0.0f, 1.0f } },
        { { 1.0f, 0.0f, 0.0f, 1.0f } },
    };

    HRESULT hr = S_OK;

    HTEST(pDevice->CreateInputLayout(aVertexDesc, RT_ELEMENTS(aVertexDesc),
          &g_vs_color[0], sizeof(g_vs_color),
          &mpInputLayout));
    HTEST(pDevice->CreateVertexShader(g_vs_color, sizeof(g_vs_color), NULL, &mpVS));
    HTEST(pDevice->CreatePixelShader(g_ps_color, sizeof(g_ps_color), NULL, &mpPS));

    D3D11_BUFFER_DESC vbd;
    D3D11_SUBRESOURCE_DATA vinitData;
    if (mfUseSameBuffer)
    {
        RT_ZERO(vbd);
        vbd.Usage               = D3D11_USAGE_IMMUTABLE;
        vbd.ByteWidth           = sizeof(aVertices1) + sizeof(aVertices2);
        vbd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
        vbd.CPUAccessFlags      = 0;
        vbd.MiscFlags           = 0;
        vbd.StructureByteStride = 0;

        unsigned char au8TmpInitData[sizeof(aVertices1) + mcbGap + sizeof(aVertices2)];
        memcpy(&au8TmpInitData[0], aVertices1, sizeof(aVertices1));
        memset(&au8TmpInitData[sizeof(aVertices1)], 0, mcbGap);
        memcpy(&au8TmpInitData[sizeof(aVertices1) + mcbGap], aVertices2, sizeof(aVertices2));

        RT_ZERO(vinitData);
        vinitData.pSysMem = au8TmpInitData;

        HTEST(pDevice->CreateBuffer(&vbd, &vinitData, &mapVB[0]));

        mapVB[1] = mapVB[0];
        mapVB[1]->AddRef();
    }
    else
    {
        RT_ZERO(vbd);
        vbd.Usage               = D3D11_USAGE_IMMUTABLE;
        vbd.ByteWidth           = sizeof(aVertices1);
        vbd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
        vbd.CPUAccessFlags      = 0;
        vbd.MiscFlags           = 0;
        vbd.StructureByteStride = 0;

        RT_ZERO(vinitData);
        vinitData.pSysMem = aVertices1;

        HTEST(pDevice->CreateBuffer(&vbd, &vinitData, &mapVB[0]));

        RT_ZERO(vbd);
        vbd.Usage               = D3D11_USAGE_IMMUTABLE;
        vbd.ByteWidth           = sizeof(aVertices2);
        vbd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
        vbd.CPUAccessFlags      = 0;
        vbd.MiscFlags           = 0;
        vbd.StructureByteStride = 0;

        RT_ZERO(vinitData);
        vinitData.pSysMem = aVertices2;

        HTEST(pDevice->CreateBuffer(&vbd, &vinitData, &mapVB[1]));
    }

    return hr;
}

HRESULT D3D11RenderDoubleVB::DoRender(D3D11DeviceProvider *pDP)
{
    ID3D11DeviceContext *pImmediateContext = pDP->ImmediateContext();

    FLOAT aColor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
    pImmediateContext->ClearRenderTargetView(pDP->RenderTargetView(), aColor);
    if (pDP->DepthStencilView())
        pImmediateContext->ClearDepthStencilView(pDP->DepthStencilView(),
                                                 D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    pImmediateContext->IASetInputLayout(mpInputLayout);
    pImmediateContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    if (mfUseSameBuffer)
    {
        UINT aStrides[] = { sizeof(Vertex1), sizeof(Vertex2) };
        UINT aOffsets[] = { 0 , 3 * sizeof(Vertex1) + mcbGap };
        pImmediateContext->IASetVertexBuffers(0, 2, mapVB, aStrides, aOffsets);
    }
    else
    {
        UINT aStrides[] = { sizeof(Vertex1), sizeof(Vertex2) };
        UINT aOffsets[] = { 0 , 0 };
        pImmediateContext->IASetVertexBuffers(0, 2, mapVB, aStrides, aOffsets);
    }

    pImmediateContext->VSSetShader(mpVS, NULL, 0);
    pImmediateContext->PSSetShader(mpPS, NULL, 0);

    D3D11_VIEWPORT Viewport;
    Viewport.TopLeftX = 0.0f;
    Viewport.TopLeftY = 0.0f;
    Viewport.Width    = (float)800;
    Viewport.Height   = (float)600;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    pImmediateContext->RSSetViewports(1, &Viewport);

    pImmediateContext->Draw(3, 0);

    return S_OK;
}


/*
 * DrawIndexed with various StartIndexLocation, BaseVertexLocation and index buffer offset.
 */

class D3D11RenderDrawIndexed: public D3D11Render
{
public:
    D3D11RenderDrawIndexed();
    virtual ~D3D11RenderDrawIndexed();
    virtual HRESULT InitRender(D3D11DeviceProvider *pDP);
    virtual HRESULT DoRender(D3D11DeviceProvider *pDP);
private:
    ID3D11InputLayout *mpInputLayout;
    ID3D11VertexShader *mpVS;
    ID3D11PixelShader *mpPS;
    ID3D11Buffer *mpVB;
    ID3D11Buffer *mpIB;

    struct Vertex
    {
        float position[3];
        float color[4];
    };
};


D3D11RenderDrawIndexed::D3D11RenderDrawIndexed()
    : mpInputLayout(0)
    , mpVS(0)
    , mpPS(0)
    , mpVB(0)
    , mpIB(0)
{
}

D3D11RenderDrawIndexed::~D3D11RenderDrawIndexed()
{
    D3D_RELEASE(mpInputLayout);
    D3D_RELEASE(mpVS);
    D3D_RELEASE(mpPS);
    D3D_RELEASE(mpVB);
    D3D_RELEASE(mpIB);
}

HRESULT D3D11RenderDrawIndexed::InitRender(D3D11DeviceProvider *pDP)
{
    ID3D11Device *pDevice = pDP->Device();

    static D3D11_INPUT_ELEMENT_DESC const aVertexDesc[] =
    {
        {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
        {"COLOR",    0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}
    };

    /* A triangle in each quadrant. Need 5 points. */
    static Vertex const aVertices[] =
    {
        { {  0.0f,  0.0f, 0.5f }, { 0.0f, 0.0f, 0.0f, 1.0f }, }, // 0: center
        { { -0.8f,  0.0f, 0.5f }, { 1.0f, 0.0f, 0.0f, 1.0f }, }, // 1: left
        { {  0.0f,  0.8f, 0.5f }, { 0.0f, 1.0f, 0.0f, 1.0f }, }, // 2: top
        { {  0.8f,  0.0f, 0.5f }, { 0.0f, 0.0f, 1.0f, 1.0f }, }, // 3: right
        { {  0.0f, -0.8f, 0.5f }, { 0.5f, 0.5f, 0.5f, 1.0f }, }, // 4: bottom

        /* A smaller copy to use BaseVertexLocation. */
        { {  0.0f,  0.0f, 0.0f }, { 0.5f, 0.5f, 0.5f, 1.0f }, }, // 0: center
        { { -0.2f,  0.0f, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f }, }, // 1: left
        { {  0.0f,  0.2f, 0.0f }, { 0.0f, 1.0f, 1.0f, 1.0f }, }, // 2: top
        { {  0.2f,  0.0f, 0.0f }, { 1.0f, 1.0f, 0.0f, 1.0f }, }, // 3: right
        { {  0.0f, -0.2f, 0.0f }, { 1.0f, 0.0f, 1.0f, 1.0f }, }, // 4: bottom
    };

    /* Four triangles. Indices for each triangle will be accessed using different
     * StartIndexLocation and index buffer offset values.
     */
    static uint16_t const aIndices[] =
    {
        /* Bottom left: left, center, bottom. */    1, 0, 4,
        /* Top left: top, center, left. */          2, 0, 1,
        /* Top right: right, center, top. */        3, 0, 2,
        /* Bottom right: bottom, center, right. */  4, 0, 3,
    };

    HRESULT hr = S_OK;

    HTEST(pDevice->CreateInputLayout(aVertexDesc, RT_ELEMENTS(aVertexDesc),
          &g_vs_color[0], sizeof(g_vs_color),
          &mpInputLayout));
    HTEST(pDevice->CreateVertexShader(g_vs_color, sizeof(g_vs_color), NULL, &mpVS));
    HTEST(pDevice->CreatePixelShader(g_ps_color, sizeof(g_ps_color), NULL, &mpPS));

    D3D11_BUFFER_DESC bd;
    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aVertices);
    bd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    D3D11_SUBRESOURCE_DATA initData;
    RT_ZERO(initData);
    initData.pSysMem = aVertices;

    HTEST(pDevice->CreateBuffer(&bd, &initData, &mpVB));

    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aIndices);
    bd.BindFlags           = D3D11_BIND_INDEX_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(initData);
    initData.pSysMem = aIndices;

    HTEST(pDevice->CreateBuffer(&bd, &initData, &mpIB));

    return hr;
}

static void drawRectangles(ID3D11DeviceContext *pImmediateContext, ID3D11Buffer *pIB, INT const BaseVertexLocation)
{
    /* Draw each triangle separately. */
    UINT offset;
    UINT StartIndexLocation;

    /* Bottom left. */
    offset = 0;
    StartIndexLocation = 0;
    pImmediateContext->IASetIndexBuffer(pIB, DXGI_FORMAT_R16_UINT, offset);
    pImmediateContext->DrawIndexed(3, StartIndexLocation, BaseVertexLocation);

    /* Top left. */
    offset = 0;
    StartIndexLocation = 3;
    pImmediateContext->IASetIndexBuffer(pIB, DXGI_FORMAT_R16_UINT, offset);
    pImmediateContext->DrawIndexed(3, StartIndexLocation, BaseVertexLocation);

    /* Top right. */
    offset = 6 * sizeof(uint16_t);
    StartIndexLocation = 0;
    pImmediateContext->IASetIndexBuffer(pIB, DXGI_FORMAT_R16_UINT, offset);
    pImmediateContext->DrawIndexed(3, StartIndexLocation, BaseVertexLocation);

    /* Bottom right. */
    offset = 6 * sizeof(uint16_t);
    StartIndexLocation = 3;
    pImmediateContext->IASetIndexBuffer(pIB, DXGI_FORMAT_R16_UINT, offset);
    pImmediateContext->DrawIndexed(3, StartIndexLocation, BaseVertexLocation);
}

HRESULT D3D11RenderDrawIndexed::DoRender(D3D11DeviceProvider *pDP)
{
    ID3D11DeviceContext *pImmediateContext = pDP->ImmediateContext();

    FLOAT aColor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
    pImmediateContext->ClearRenderTargetView(pDP->RenderTargetView(), aColor);
    if (pDP->DepthStencilView())
        pImmediateContext->ClearDepthStencilView(pDP->DepthStencilView(),
                                                 D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    pImmediateContext->IASetInputLayout(mpInputLayout);
    pImmediateContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    pImmediateContext->IASetVertexBuffers(0, 1, &mpVB, &stride, &offset);

    pImmediateContext->VSSetShader(mpVS, NULL, 0);
    pImmediateContext->PSSetShader(mpPS, NULL, 0);

    INT BaseVertexLocation;
    BaseVertexLocation = 0;
    drawRectangles(pImmediateContext, mpIB, BaseVertexLocation);
    BaseVertexLocation = 5;
    drawRectangles(pImmediateContext, mpIB, BaseVertexLocation);

    return S_OK;
}


/*
 * Test a draw from guest.
 */

static unsigned char const dxbc_vs_8_shid_0[] =
{
    0x44, 0x58, 0x42, 0x43, 0x3c, 0x4b, 0x22, 0x00, 0x8d, 0x54, 0x9d, 0xfc, 0x24, 0x3c, 0xdb, 0xe9,
    0x65, 0x0c, 0xf7, 0x39, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x2c, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x4e,
    0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x41, 0x54, 0x54, 0x52,
    0x49, 0x42, 0x00, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x4c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00,
    0x41, 0x54, 0x54, 0x52, 0x49, 0x42, 0x00, 0x00, 0x53, 0x48, 0x44, 0x52, 0xf0, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x01, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x6a, 0x08, 0x01, 0x01, 0x59, 0x00, 0x00, 0x04,
    0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x59, 0x08, 0x00, 0x04,
    0x46, 0x8e, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03,
    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 0x12, 0x10, 0x10, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x80, 0x01, 0x80, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b,
    0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x86, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0x85, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x20, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08,
    0xf2, 0x20, 0x10, 0x80, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x04,
    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01
};
static unsigned char const dxbc_ps_8_shid_1[] =
{
    0x44, 0x58, 0x42, 0x43, 0x32, 0x53, 0xc9, 0xda, 0xb6, 0x69, 0x0f, 0x34, 0xae, 0xf8, 0x2a, 0x09,
    0xe0, 0x03, 0x77, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x2c, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x4e,
    0x4c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50,
    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x41, 0x54, 0x54, 0x52, 0x49, 0x42, 0x00, 0x00,
    0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 0x41, 0x52, 0x47, 0x45,
    0x54, 0x00, 0x00, 0x00, 0x53, 0x48, 0x44, 0x52, 0x4c, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x6a, 0x08, 0x01, 0x01, 0x62, 0x10, 0x00, 0x04, 0xf2, 0x10, 0x10, 0x80,
    0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x80,
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x07, 0xf2, 0x20, 0x10, 0x80,
    0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x80, 0x01, 0x80, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01
};

static uint8_t *readBmpFile(char const *pszFilename, uint32_t *pWidth, uint32_t *pHeight, uint32_t *pcbData)
{
    uint8_t *pu8Data = NULL;

    RTFILE f = NIL_RTFILE;
    int rc = RTFileOpen(&f, pszFilename, RTFILE_O_READ | RTFILE_O_OPEN | RTFILE_O_DENY_WRITE);
    if (RT_SUCCESS(rc))
    {
        BMPFILEHDR fileHdr;
        rc = RTFileRead(f, &fileHdr, sizeof(fileHdr), NULL);
        if (RT_SUCCESS(rc))
        {
            *pcbData = (fileHdr.cbFileSize - fileHdr.offBits) / 4; // < /4 hack because writing was wrong
            uint32_t const cbHdr = fileHdr.offBits - sizeof(fileHdr);
            if (cbHdr == sizeof(BITMAPV4HEADER))
            {
                BITMAPV4HEADER hdrV4;
                rc = RTFileRead(f, &hdrV4, sizeof(hdrV4), NULL);
                if (RT_SUCCESS(rc))
                {
                    *pWidth = hdrV4.bV4Width;
                    *pHeight = (uint32_t)-hdrV4.bV4Height;
                }
            }
            else if (cbHdr == sizeof(BMPWIN3XINFOHDR))
            {
                BMPWIN3XINFOHDR coreHdr;
                rc = RTFileRead(f, &coreHdr, sizeof(coreHdr), NULL);
                if (RT_SUCCESS(rc))
                {
                    *pWidth = coreHdr.uWidth;
                    *pHeight = (uint32_t)(-(int32_t)coreHdr.uHeight);
                }
            }
            if (RT_SUCCESS(rc))
            {
                pu8Data = (uint8_t *)RTMemAlloc(*pcbData);
                if (pu8Data)
                    rc = RTFileRead(f, pu8Data, *pcbData, NULL);
            }
        }

        RTFileClose(f);
    }

    if (RT_FAILURE(rc))
    {
        RTMemFree(pu8Data);
        pu8Data = NULL;
    }

    return pu8Data;
}

class D3D11RenderTest: public D3D11Render
{
public:
    D3D11RenderTest();
    virtual ~D3D11RenderTest();
    virtual HRESULT InitRender(D3D11DeviceProvider *pDP);
    virtual HRESULT DoRender(D3D11DeviceProvider *pDP);
private:
    ID3D11InputLayout *mpInputLayout;
    ID3D11VertexShader *mpVS;
    ID3D11PixelShader *mpPS;
    ID3D11Buffer *mpIB;
    ID3D11Buffer *mpVB;
    ID3D11Buffer *mpVBInstanceData;
    ID3D11Buffer *mpCB_VS0;
    ID3D11Buffer *mpCB_VS1;
    ID3D11Buffer *mpCB_PS;
    ID3D11Buffer *mpSR_0;
    ID3D11Texture2D *mpSR_1;
    ID3D11ShaderResourceView *mpSRV_0;
    ID3D11ShaderResourceView *mpSRV_1;
    ID3D11SamplerState *mpSampler;
    ID3D11BlendState *mpBlend;
    ID3D11RasterizerState *mpRasterizerState;
    ID3D11DepthStencilState *mpDepthStencilState;
    ID3D11UnorderedAccessView *mpUnorderedAccessView;

    struct Vertex
    {
        float e0[2];
        short e1[2];
    };
#if 0
    struct InstanceData
    {
        short e1[2];
        short e2[2];
        short e3[2];
        int32_t e4[1];
    };
#endif
};


D3D11RenderTest::D3D11RenderTest()
    : mpInputLayout(0)
    , mpVS(0)
    , mpPS(0)
    , mpIB(0)
    , mpVB(0)
    , mpVBInstanceData(0)
    , mpCB_VS0(0)
    , mpCB_VS1(0)
    , mpCB_PS(0)
    , mpSR_0(0)
    , mpSR_1(0)
    , mpSRV_0(0)
    , mpSRV_1(0)
    , mpSampler(0)
    , mpBlend(0)
    , mpRasterizerState(0)
    , mpDepthStencilState(0)
    , mpUnorderedAccessView(0)
{
}

D3D11RenderTest::~D3D11RenderTest()
{
    D3D_RELEASE(mpInputLayout);
    D3D_RELEASE(mpVS);
    D3D_RELEASE(mpPS);
    D3D_RELEASE(mpIB);
    D3D_RELEASE(mpVB);
    D3D_RELEASE(mpVBInstanceData);
    D3D_RELEASE(mpCB_VS0);
    D3D_RELEASE(mpCB_VS1);
    D3D_RELEASE(mpCB_PS);
    D3D_RELEASE(mpSR_0);
    D3D_RELEASE(mpSR_1);
    D3D_RELEASE(mpSRV_0);
    D3D_RELEASE(mpSRV_1);
    D3D_RELEASE(mpSampler);
    D3D_RELEASE(mpBlend);
    D3D_RELEASE(mpRasterizerState);
    D3D_RELEASE(mpDepthStencilState);
    D3D_RELEASE(mpUnorderedAccessView);
}

HRESULT D3D11RenderTest::InitRender(D3D11DeviceProvider *pDP)
{
    ID3D11Device *pDevice = pDP->Device();

    static D3D11_INPUT_ELEMENT_DESC const aVertexDesc[] =
    {
        {"ATTRIB", 0, DXGI_FORMAT_R32G32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0},
        {"ATTRIB", 1, DXGI_FORMAT_R16G16_SINT,  0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0},
    };

    static Vertex const aVertices[] =
    {
        { { 0.000000, 0.000000 },{ 0, 256 }, },
        { { 0.000000, 0.000000 },{ 0, 256 }, },
        { { 0.000000, 409.000000 },{ 0, 256 }, },
        { { 756.000000, 0.000000 },{ 0, 256 }, },
        { { 756.000000, 409.000000 },{ 0, 256 }, },
        { { 756.000000, 409.000000 },{ 0, 256 }, },
        { { 0.000000, 34.000000 },{ 1, 256 }, },
        { { 0.000000, 34.000000 },{ 1, 256 }, },
        { { 0.000000, 409.000000 },{ 1, 256 }, },
        { { 756.000000, 34.000000 },{ 1, 256 }, },
        { { 756.000000, 409.000000 },{ 1, 256 }, },
        { { 756.000000, 409.000000 },{ 1, 256 }, },
    };

#if 0
    static uint16_t const aIndices[] =
    {
        { 0 },
        { 1 },
        { 2 },
        { 0 },
        { 2 },
        { 3 },
    };

    static InstanceData const aInstanceData[] =
    {
        { { 16, 23 },{ 24, 30 },{ 0, 7 },{ 0 } },
    };
#endif

    HRESULT hr = S_OK;

    HTEST(pDevice->CreateInputLayout(aVertexDesc, RT_ELEMENTS(aVertexDesc),
          &dxbc_vs_8_shid_0[0], sizeof(dxbc_vs_8_shid_0),
          &mpInputLayout));
    HTEST(pDevice->CreateVertexShader(dxbc_vs_8_shid_0, sizeof(dxbc_vs_8_shid_0), NULL, &mpVS));
    HTEST(pDevice->CreatePixelShader(dxbc_ps_8_shid_1, sizeof(dxbc_ps_8_shid_1), NULL, &mpPS));

    D3D11_BUFFER_DESC bd;
    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aVertices);
    bd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    D3D11_SUBRESOURCE_DATA vinitData;
    RT_ZERO(vinitData);
    vinitData.pSysMem = aVertices;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpVB));

#if 0
    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aInstanceData);
    bd.BindFlags           = D3D11_BIND_VERTEX_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(vinitData);
    vinitData.pSysMem = aInstanceData;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpVBInstanceData));

    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aIndices);
    bd.BindFlags           = D3D11_BIND_INDEX_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(vinitData);
    vinitData.pSysMem = aIndices;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpIB));
#endif

    float aCB_VS0[] =
    {
        0.002645, -1.000000, -0.004889, 1.000000,
        1.000000, 0.000000, 0.000000, 0.000000,
        1.000000, 0.000000, 0.000000, 0.000000,
    };

    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aCB_VS0);
    bd.BindFlags           = D3D11_BIND_CONSTANT_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(vinitData);
    vinitData.pSysMem = aCB_VS0;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpCB_VS0));

    float aCB_VS1[250 * 4] =
    {
        0.976470, 0.976470, 0.976470, 1.000000,
        0.976470, 0.976470, 0.976470, 1.000000,
    };

    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aCB_VS1);
    bd.BindFlags           = D3D11_BIND_CONSTANT_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(vinitData);
    vinitData.pSysMem = aCB_VS1;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpCB_VS1));

    static float const aCB_PS[] =
    {
        0.000000, 1.000000, 1.399999, 1.000000,
    };

    RT_ZERO(bd);
    bd.Usage               = D3D11_USAGE_IMMUTABLE;
    bd.ByteWidth           = sizeof(aCB_PS);
    bd.BindFlags           = D3D11_BIND_CONSTANT_BUFFER;
    bd.CPUAccessFlags      = 0;
    bd.MiscFlags           = 0;
    bd.StructureByteStride = 0;

    RT_ZERO(vinitData);
    vinitData.pSysMem = aCB_PS;

    HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpCB_PS));

#if 0
    const char *pszSR;
    uint8_t *pu8Data;
    uint32_t w, h, cbData;

    pszSR = "C:\\Develop\\vbox\\trunk\\out\\win.amd64\\debug\\bin\\bmp\\sr-6691.bmp";
    pu8Data = readBmpFile(pszSR, &w, &h, &cbData);
    if (pu8Data)
    {
        RT_ZERO(bd);
        bd.Usage               = D3D11_USAGE_IMMUTABLE;
        bd.ByteWidth           = cbData;
        bd.BindFlags           = D3D11_BIND_SHADER_RESOURCE;
        bd.CPUAccessFlags      = 0;
        bd.MiscFlags           = 0;
        bd.StructureByteStride = 0;

        RT_ZERO(vinitData);
        vinitData.pSysMem = pu8Data;

        HTEST(pDevice->CreateBuffer(&bd, &vinitData, &mpSR_0));

        RTMemFree(pu8Data);

        D3D11_SHADER_RESOURCE_VIEW_DESC desc;
        RT_ZERO(desc);
        desc.Format = DXGI_FORMAT_R8_UINT;
        desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
        desc.Buffer.FirstElement = 0;
        desc.Buffer.NumElements = w;
        HTEST(pDevice->CreateShaderResourceView(mpSR_0, &desc, &mpSRV_0));
    }

    pszSR = "C:\\Develop\\vbox\\trunk\\out\\win.amd64\\debug\\bin\\bmp\\sr-6692.bmp";
    pu8Data = readBmpFile(pszSR, &w, &h, &cbData);
    if (pu8Data)
    {
        D3D11_TEXTURE2D_DESC td;
        RT_ZERO(td);
        td.Width              = w;
        td.Height             = h;
        td.MipLevels          = 1;
        td.ArraySize          = 1;
        td.Format             = DXGI_FORMAT_B8G8R8A8_UNORM;
        td.SampleDesc.Count   = 1;
        td.SampleDesc.Quality = 0;
        td.Usage              = D3D11_USAGE_DEFAULT;
        td.BindFlags          = D3D11_BIND_SHADER_RESOURCE;
        td.CPUAccessFlags     = 0;
        td.MiscFlags          = 0;

        D3D11_SUBRESOURCE_DATA initData;
        initData.pSysMem          = pu8Data;
        initData.SysMemPitch      = w * 4;
        initData.SysMemSlicePitch = 0;

        HTEST(pDevice->CreateTexture2D(&td, &initData, &mpSR_1));

        D3D11_SHADER_RESOURCE_VIEW_DESC desc;
        RT_ZERO(desc);
        desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
        desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        desc.Texture2D.MostDetailedMip = 0;
        desc.Texture2D.MipLevels = 1;

        HTEST(pDevice->CreateShaderResourceView(mpSR_1, &desc, &mpSRV_1));

        RTMemFree(pu8Data);
    }

    D3D11_SAMPLER_DESC desc;
    desc.Filter         = (D3D11_FILTER)0;
    desc.AddressU       = (D3D11_TEXTURE_ADDRESS_MODE)3;
    desc.AddressV       = (D3D11_TEXTURE_ADDRESS_MODE)3;
    desc.AddressW       = (D3D11_TEXTURE_ADDRESS_MODE)3;
    desc.MipLODBias     = 0.0;
    desc.MaxAnisotropy  = 0;
    desc.ComparisonFunc = (D3D11_COMPARISON_FUNC)1;
    desc.BorderColor[0] = 0.0;
    desc.BorderColor[1] = 0.0;
    desc.BorderColor[2] = 0.0;
    desc.BorderColor[3] = 0.0;
    desc.MinLOD         = 0.0;
    desc.MaxLOD         = 0.0;

    HTEST(pDevice->CreateSamplerState(&desc, &mpSampler));
#endif

#if 1
    D3D11_BLEND_DESC BlendDesc;
    RT_ZERO(BlendDesc);
    BlendDesc.AlphaToCoverageEnable = FALSE;
    BlendDesc.IndependentBlendEnable = FALSE;
    for (int i = 0; i < 8; ++i)
    {
        BlendDesc.RenderTarget[i].BlendEnable           = FALSE;
//        BlendDesc.RenderTarget[i].SrcBlend              = dxBlendFactorColor(12);
//        BlendDesc.RenderTarget[i].DestBlend             = dxBlendFactorColor(4);
//        BlendDesc.RenderTarget[i].BlendOp               = dxBlendOp         (1);
//        BlendDesc.RenderTarget[i].SrcBlendAlpha         = dxBlendFactorAlpha(12);
//        BlendDesc.RenderTarget[i].DestBlendAlpha        = dxBlendFactorAlpha(4);
//        BlendDesc.RenderTarget[i].BlendOpAlpha          = dxBlendOp         (1);
        BlendDesc.RenderTarget[i].RenderTargetWriteMask = 7;
        /** @todo logicOpEnable and logicOp */
    }

    HTEST(pDevice->CreateBlendState(&BlendDesc, &mpBlend));
#endif

#if 1
    D3D11_RASTERIZER_DESC rs;
    rs.FillMode              = dxFillMode(3);
    rs.CullMode              = D3D11_CULL_BACK;
    rs.FrontCounterClockwise = FALSE;
    rs.DepthBias             = 0;
    rs.DepthBiasClamp        = 0.0;
    rs.SlopeScaledDepthBias  = 0.0;
    rs.DepthClipEnable       = TRUE;
    rs.ScissorEnable         = TRUE;
    rs.MultisampleEnable     = FALSE;
    rs.AntialiasedLineEnable = FALSE;

    HTEST(pDevice->CreateRasterizerState(&rs, &mpRasterizerState));
#endif

    D3D11_DEPTH_STENCIL_DESC ds;
    ds.DepthEnable                  = FALSE;
    ds.DepthWriteMask               = (D3D11_DEPTH_WRITE_MASK)1;
    ds.DepthFunc                    = (D3D11_COMPARISON_FUNC)2;
    ds.StencilEnable                = FALSE;
    ds.StencilReadMask              = 0;
    ds.StencilWriteMask             = 0;
    ds.FrontFace.StencilFailOp      = (D3D11_STENCIL_OP)1;
    ds.FrontFace.StencilDepthFailOp = (D3D11_STENCIL_OP)1;
    ds.FrontFace.StencilPassOp      = (D3D11_STENCIL_OP)1;
    ds.FrontFace.StencilFunc        = (D3D11_COMPARISON_FUNC)8;
    ds.BackFace.StencilFailOp       = (D3D11_STENCIL_OP)1;
    ds.BackFace.StencilDepthFailOp  = (D3D11_STENCIL_OP)1;
    ds.BackFace.StencilPassOp       = (D3D11_STENCIL_OP)1;
    ds.BackFace.StencilFunc         = (D3D11_COMPARISON_FUNC)8;

    HTEST(pDevice->CreateDepthStencilState(&ds, &mpDepthStencilState));

    return hr;
}

/*
- constant buffers
;- samplers
- shaders
;- shader resources
;- UA views
;- index buffer
- input layout
- primitive topology
- vertex buffers
- blend state
- depth stencil state
- render targets and UA views
- scissor rects
- rasterizer state
- viewports
- predication
- min LOD
- SO targets 
 */


HRESULT D3D11RenderTest::DoRender(D3D11DeviceProvider *pDP)
{
    ID3D11DeviceContext *pImmediateContext = pDP->ImmediateContext();

    FLOAT aColor[4] = { 0.0f, 0.0f, 1.0f, 0.0f };
    pImmediateContext->ClearRenderTargetView(pDP->RenderTargetView(), aColor);
    if (pDP->DepthStencilView())
        pImmediateContext->ClearDepthStencilView(pDP->DepthStencilView(),
                                                 D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    pImmediateContext->IASetInputLayout(mpInputLayout);
    pImmediateContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

    ID3D11Buffer *apVB[1] = { mpVB };
    UINT aStride[1] = { sizeof(Vertex) };
    UINT aOffset[1] = { 0 };
    pImmediateContext->IASetVertexBuffers(0, 1, apVB, aStride, aOffset);

//    pImmediateContext->IASetIndexBuffer(mpIB, DXGI_FORMAT_R16_UINT, 0);

//    ID3D11ShaderResourceView *apShaderResourceView[] = { mpSRV_0, mpSRV_1 };
//    pImmediateContext->PSSetShaderResources(0, 2, apShaderResourceView);

//    ID3D11SamplerState *apSampler[] = { mpSampler, mpSampler };
//    pImmediateContext->PSSetSamplers(0, 2, apSampler);

    float const blendFactor[4] = { 1.000000, 1.000000, -0.000000, -0.000000 };
    pImmediateContext->OMSetBlendState(mpBlend, blendFactor, 0xFFFFFFFF);

    pImmediateContext->RSSetState(mpRasterizerState);

    pImmediateContext->OMSetDepthStencilState(mpDepthStencilState, 0);

    ID3D11Buffer *apCB_VS[2] = { mpCB_VS0, mpCB_VS1 };
    pImmediateContext->VSSetConstantBuffers(0, RT_ELEMENTS(apCB_VS), apCB_VS);
    pImmediateContext->PSSetConstantBuffers(0, 1, &mpCB_PS);

    pImmediateContext->VSSetShader(mpVS, NULL, 0);
    pImmediateContext->PSSetShader(mpPS, NULL, 0);

    pImmediateContext->Draw(12, 0);

    return S_OK;
}


/*
 * "Public" interface.
 */

D3D11Render *CreateRender(int iRenderId)
{
    switch (iRenderId)
    {
        case 0:
            return new D3D11RenderClear();
        case 1:
            return new D3D11RenderTriangleShader();
        case 2:
            return new D3D11RenderDoubleVB(false);
        case 3:
            return new D3D11RenderDoubleVB(true);
        case 4:
            return new D3D11RenderDrawIndexed();
        case 5:
            return new D3D11RenderTest();
        default:
            break;
    }
    return 0;
}

void DeleteRender(D3D11Render *pRender)
{
    if (pRender)
        delete pRender;
}
